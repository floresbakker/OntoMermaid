prefix dcm:         <http://purl.org/dc/dcmitype/>
prefix dct:         <http://purl.org/dc/terms/>
prefix foaf:        <http://xmlns.com/foaf/0.1/>
prefix html:        <https://www.w3.org/html/model/def/>
prefix owl:         <http://www.w3.org/2002/07/owl#>
prefix prov:        <http://www.w3.org/ns/prov#>
prefix rdf:         <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfa:        <http://www.w3.org/ns/rdfa#>
prefix rdfs:        <http://www.w3.org/2000/01/rdf-schema#>
prefix sh:          <http://www.w3.org/ns/shacl#>
prefix skos:        <http://www.w3.org/2004/02/skos/core#>
prefix status:      <http://purl.org/adms/status/>
prefix vann:        <http://purl.org/vocab/vann/>
prefix void:        <http://rdfs.org/ns/void#>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

prefix doc:         <https://mermaid.org/ontomermaid/doc/id/>
prefix decl:        <https://mermaid.org/ontomermaid/model/decl/>
prefix function:    <https://mermaid.org/ontomermaid/model/function/>
prefix graph:       <https://mermaid.org/ontomermaid/model/graph/>
prefix list:        <https://mermaid.org/ontomermaid/model/list/>
prefix mermaid:     <https://mermaid.org/ontomermaid/model/def/>
prefix parameter:   <https://mermaid.org/ontomermaid/model/parameter/>
prefix rule:        <https://mermaid.org/ontomermaid/model/rule/>
prefix shp:         <https://mermaid.org/ontomermaid/model/shp/>
prefix standard:    <https://mermaid.org/ontomermaid/id/standard/>
prefix target:      <https://mermaid.org/ontomermaid/model/target/>

mermaid: {
  mermaid:
    a
      owl:Ontology,
      void:Dataset;
    dct:conformsTo 'https://mermaid.js.org/'^^xsd:anyURI;
    dct:created '2023-07-19'^^xsd:date;
    dct:creator
      'Flores Bakker',
      'Wouter Beek';
    dct:description '''The OntoMermaid Vocabulary models OWL constructs into Mermaid. Mermaid itself is a JavaScript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams. The main purpose of Mermaid is to help documentation catch up with development. This ontology defines the elements and relationships used within Mermaid diagrams, allowing for a standardized way to describe and interact with Mermaid diagrams in the context of the Semantic Web.'''@en;
    dct:abstract '''The OntoMermaid Vocabulary models OWL constructs into Mermaid. Mermaid itself is a JavaScript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams. The main purpose of Mermaid is to help documentation catch up with development. This ontology defines the elements and relationships used within Mermaid diagrams, allowing for a standardized way to describe and interact with Mermaid diagrams in the context of the Semantic Web.'''@en;
    dct:language 'iso639-1:en';
    dct:license 'http://creativecommons.org/licenses/by/4.0'^^xsd:anyURI;
    dct:publisher <https://www.w3.org/community/mermaid/>;
    dct:source <https://github.com/floresbakker/mermaid/>;
    dct:subject 'Mermaid'@en;
    dct:title 'OntoMermaid Vocabulary'@en;
    foaf:homepage 'https://www.w3.org/community/mermaid/'^^xsd:anyURI;
    owl:imports
      dct:,
      owl:,
      prov:,
      rdf:,
      rdfs:,
      sh:,
      skos:;
    sh:declare
      decl:dcm,
      decl:dct,
      decl:doc,
      decl:foaf,
      decl:function,
      decl:html,
      decl:mermaid,
      decl:owl,
      decl:prov,
      decl:rdf,
      decl:rdfs,
      decl:rule,
      decl:sh,
      decl:shp,
      decl:skos,
      decl:status,
      decl:vann,
      decl:void,
      decl:xsd;            
    owl:versionInfo '0.1.0';
    owl:versionIRI <https://github.com/floresbakker/mermaid/tree/main>;
    vann:preferredNamespacePrefix 'mermaid';
    vann:preferredNamespaceUri 'https://mermaid.org/ontomermaid/model/def/'^^xsd:anyURI;
    void:subSet graph:model;
    void:uriRegexPattern '^https://mermaid.org/ontomermaid/model/def/';
    void:uriSpace 'https://mermaid.org/ontomermaid/model/def/'^^xsd:anyURI.

  decl:dcm
    sh:prefix "dcm";
    sh:namespace "http://purl.org/dc/dcmitype/"^^xsd:anyURI.

  decl:dct
    sh:prefix "dct";
    sh:namespace "http://purl.org/dc/terms/"^^xsd:anyURI.

  decl:doc
    sh:prefix "doc";
    sh:namespace "https://mermaid.org/ontomermaid/doc/id/"^^xsd:anyURI.
    
  decl:foaf
    sh:prefix "foaf";
    sh:namespace "http://xmlns.com/foaf/0.1/"^^xsd:anyURI.
    
  decl:function
    sh:prefix "function";
    sh:namespace "https://mermaid.org/ontomermaid/model/function/"^^xsd:anyURI.    
  
  decl:html
    sh:prefix "html";
    sh:namespace "https://www.w3.org/html/model/def/"^^xsd:anyURI.

  decl:mermaid
    sh:prefix "mermaid";
    sh:namespace "https://mermaid.org/ontomermaid/model/def/"^^xsd:anyURI.

  decl:owl
    sh:prefix "owl";
    sh:namespace "http://www.w3.org/2002/07/owl#"^^xsd:anyURI.
    
  decl:prov
    sh:prefix "prov";
    sh:namespace "http://www.w3.org/ns/prov#"^^xsd:anyURI.

  decl:rdf
    sh:prefix "rdf";
    sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#"^^xsd:anyURI.

  decl:rdfs
    sh:prefix "rdfs";
    sh:namespace "http://www.w3.org/2000/01/rdf-schema#"^^xsd:anyURI.

  decl:rule
    sh:prefix "rule";
    sh:namespace "https://mermaid.org/ontomermaid/model/rule/"^^xsd:anyURI.

  decl:shp
    sh:prefix "shp";
    sh:namespace "https://mermaid.org/ontomermaid/model/shp/"^^xsd:anyURI.

  decl:sh
    sh:prefix "sh";
    sh:namespace "http://www.w3.org/ns/shacl#"^^xsd:anyURI.

  decl:skos
    sh:prefix "skos";
    sh:namespace "http://www.w3.org/2004/02/skos/core#"^^xsd:anyURI.
    
  decl:status
    sh:prefix "status";
    sh:namespace "http://purl.org/adms/status/"^^xsd:anyURI.    

  decl:vann
    sh:prefix "vann";
    sh:namespace "http://purl.org/vocab/vann/"^^xsd:anyURI.

  decl:void
    sh:prefix "void";
    sh:namespace "http://rdfs.org/ns/void#"^^xsd:anyURI.
    
  decl:xsd
    sh:prefix "xsd";
    sh:namespace "http://www.w3.org/2001/XMLSchema#"^^xsd:anyURI.

  standard:mermaid
    a dct:Standard;
    dct:created '2023-07-19'^^xsd:date;
    dct:source 'https://mermaid.js.org/'^^xsd:anyURI;
    skos:prefLabel 'Mermaid diagram language'@en.

### Mermaid diagram

  shp:Diagram
    a sh:NodeShape;
    sh:description 'A Mermaid diagram.'@en;
    sh:name 'Mermaid diagram'@en;
    sh:rule rule:Diagram;
    sh:target target:Diagram;
    rdfs:isDefinedBy mermaid:.

  mermaid:Diagram
    a owl:Class;
    skos:prefLabel "Mermaid diagram"@en;
    skos:definition "An HTML document containing a Mermaid diagram"@en.

 target:Diagram
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {
 optional
  { 
    {
      select ?modelComponent where {
        {
          ?modelComponent a owl:Class.
        }
        union
        {
          ?modelComponent a rdfs:Class.
        }
        union
        {
          ?modelComponent rdfs:subClassOf []
        }
        union
        {
          ?modelComponent owl:equivalentClass []
        }
        union
        {
          ?modelComponent owl:unionOf []
        }
        union
        {
          ?modelComponent owl:intersectionOf []
        }
        union
        {
          ?modelComponent owl:complementOf []
        }
        union
        {
          ?modelComponent owl:oneOf []
        }
        union
        {
          ?modelComponent owl:allValuesFrom []
        }
        union
        {
          ?modelComponent owl:someValuesFrom []
        }
        union
        {
          ?modelComponent owl:hasValue []
        }
        union
        {
          ?modelComponent owl:cardinality []
        }
        union
        {
          ?modelComponent owl:maxCardinality []
        }
        union
        {
          ?modelComponent owl:minCardinality []
        }
        union
        {
          ?modelComponent rdf:type rdf:Property
        }
        union
        {
          ?modelComponent rdf:type owl:DatatypeProperty.
        }
        union
        {
          ?modelComponent rdf:type owl:ObjectProperty.
        }
        union
        {
          ?modelComponent rdfs:subPropertyOf []
          filter not exists {
            ?modelComponent rdf:type owl:AnnotationProperty
          }.
          filter not exists {
            ?modelComponent rdf:type owl:InverseFunctionalProperty
          }
          filter not exists {
            ?modelComponent rdf:type owl:FunctionalProperty
          }
        }
        union
        {
          ?modelComponent owl:equivalentProperty [].
        }
        union
        {
          ?modelComponent owl:inverseOf [].
        }
      }
    }

    filter not exists {
      ?node
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom ?modelComponent.
    }
  }
  bind(if(!bound(?modelComponent), true, ?unboundDummy ) as $this)
}
''';
    rdfs:isDefinedBy mermaid:.

rule:Diagram
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram for an ontology or part of an ontology.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule'@en;
    sh:construct '''

CONSTRUCT {

# Construct the entire HTML document containing the Mermaid diagram

?doc
  rdf:type html:Document;
  prov:wasGeneratedBy $this;
  rdf:_1 ?docType ;
  rdf:_2 ?root .

?docType 
  rdf:type html:DocumentType;
  html:documentTypeName 'html'.
  
?root 
  rdf:type html:Html; 
  rdf:_1 ?head;
  rdf:_2 ?body.

?head
  rdf:type html:Head.
  
?body
  rdf:type html:Body;
  rdf:_1 ?div.
  
?div
  rdf:type html:Div;
  rdf:_1 ?pre;
  rdf:_2 ?script.
  
?pre
  rdf:type html:Pre;
  rdf:_1 ?preText;
  ?member ?node.

?preText
  rdf:type html:Text;
  html:class "mermaid";
  html:fragment """
%%{
                  init: {
                  "flowchart":{
                  "useMaxWidth": 0
                  }
                  }
                  }%%
                  graph TB
                  classDef Datatype fill:#9c6,stroke:#9c6;
""".

?script 
  rdf:type html:Script;
  html:type "module";
  rdf:_1 ?scriptText.

?scriptText
  rdf:type html:Text;
  html:fragment """
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
                   mermaid.initialize({ startOnLoad: true, maxTextSize : 99999999 });
""".
  
} where {

 {select ?node ((count(?prevIndex)) as ?indexMember)
   where{
    ?node mermaid:fragment ?index.
    optional {           
              ?prevNode mermaid:fragment ?prevIndex.
              filter(?prevIndex < ?index)
             } 
     } group by ?node
  }
  
bind(iri(concat(str(rdf:), "_", str(?indexMember+1))) as ?member)

bind(iri(concat(str(doc:), struuid())) as ?doc)
bind(iri(concat(str(doc:), struuid())) as ?docType)
bind(iri(concat(str(doc:), struuid())) as ?root)
bind(iri(concat(str(doc:), struuid())) as ?head)
bind(iri(concat(str(doc:), struuid())) as ?body)
bind(iri(concat(str(doc:), struuid())) as ?div)
bind(iri(concat(str(doc:), struuid())) as ?pre)
bind(iri(concat(str(doc:), struuid())) as ?script)
bind(iri(concat(str(doc:), struuid())) as ?preText)
bind(iri(concat(str(doc:), struuid())) as ?scriptText)

}
''';
    rdfs:isDefinedBy mermaid:.


### OWL Class

 shp:SerializableOwlClass
    a sh:NodeShape;
    sh:rule rule:SerializeOwlClass;
    sh:target target:SerializableOwlClass;
    skos:prefLabel 'Serializable owl class shape'@en.

  target:SerializableOwlClass
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;    
    sh:select '''

select $this {
  # Any OWL or RDFS class that is not further expressed in class expression
  
  {$this a owl:Class.}
  UNION
  {$this a rdfs:Class.}
  
  filter not exists {
    $this rdfs:subClassOf []
  }
  filter not exists {
    $this owl:equivalentClass []
  }
  filter not exists {
    $this owl:unionOf []
  }
  filter not exists {
    $this owl:intersectionOf []
  }
  filter not exists {
    $this owl:complementOf []
  }
  filter not exists {
    $this owl:oneOf []
  }
  
  # The OWL class must not have an Mermaid diagram language string yet
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:SerializeOwlClass
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for an OWL Class.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl class'@en;
    sh:construct '''
    
construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this, shp:SerializableOwlClass.
  
} where {
  bind(iri(concat(str(doc:), struuid())) as ?node)
  bind(if(isBlank($this),str($this),concat(str($this),"((",function:getPrefixedIRI($this), "))")) as ?mermaidLabel)
}
'''.

### OWL Restriction

shp:SerializableOwlRestriction_AllValuesFrom
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_AllValuesFrom;
    sh:target target:SerializableOwlRestriction_AllValuesFrom;
    skos:prefLabel 'Serializable owl restriction owl:allValuesFrom shape'@en.

  target:SerializableOwlRestriction_AllValuesFrom
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL class restriction for which the underlying expressions are already serialized to Mermaid diagram language
  
  $this a owl:Restriction;
        owl:allValuesFrom [];
        owl:onProperty ?someProperty.
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
 '''.

  rule:SerializeOwlRestriction_AllValuesFrom
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:allValuesFrom.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:allValuesFrom'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this, shp:SerializableOwlRestriction_AllValuesFrom.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:allValuesFrom ?someClass;
        owl:onProperty ?someProperty.
		
  # Establish the label and identifier for the inner OWL logic
  BIND(IF(isBlank(?someClass), str(?someClass), function:getPrefixedIRI(?someClass)) as ?mermaidLabelClass)
  BIND(IF(isBlank(?someProperty), str(?someProperty), function:getPrefixedIRI(?someProperty)) as ?mermaidLabelProperty)
  BIND(IF(isBlank(?someClass)   ,CONCAT(?mermaidLabelClass   , "\\n"),CONCAT(str($this),str(?someClass)   , "((", ?mermaidLabelClass,   "))\\n")) as ?mermaidClass)
  BIND(IF(isBlank(?someProperty),CONCAT(?mermaidLabelProperty, "\\n"),CONCAT(str($this),str(?someProperty), "[",  ?mermaidLabelProperty,"]\\n"))  as ?mermaidProperty)
  
  # Establish the inner OWL logic 
  BIND(CONCAT(STR($this),"thing((thing)) --> ", ?mermaidProperty, "\\n", ?mermaidProperty, " -- only --> ", ?mermaidClass) as ?mermaidDefinition)
   
  # Establish label and identifier for the outer OWL logic
  BIND(IF(isBlank($this), ?unboundDummy, function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  
  # Establish the outer OWL logic
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[Restriction &forall; R C]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, "[Restriction &forall; R C]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
  
}
'''.


shp:SerializableOwlRestriction_SomeValuesFrom
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_SomeValuesFrom;
    sh:target target:SerializableOwlRestriction_SomeValuesFrom;
    skos:prefLabel 'Serializable owl restriction owl:someValuesFrom shape'@en.

  target:SerializableOwlRestriction_SomeValuesFrom
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''
    
select $this {

  # A OWL class restriction for which the underlying class expressions are already serialized to Mermaid diagram language
  
  $this a owl:Restriction;
        owl:someValuesFrom [];
        owl:onProperty ?someProperty.    
		
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
 '''.

  rule:SerializeOwlRestriction_SomeValuesFrom
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:someValuesFrom.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:someValuesFrom'@en;
    sh:construct '''
    
construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableOwlRestriction_SomeValuesFrom.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:someValuesFrom ?someClass;
        owl:onProperty ?someProperty.
  
  # Establish the label and identifier for the inner OWL logic
  BIND(IF(isBlank(?someClass), str(?someClass), function:getPrefixedIRI(?someClass)) as ?mermaidLabelClass)
  BIND(IF(isBlank(?someProperty), str(?someProperty), function:getPrefixedIRI(?someProperty)) as ?mermaidLabelProperty)
  BIND(IF(isBlank(?someClass)   ,CONCAT(?mermaidLabelClass   , "\\n"),CONCAT(str($this),str(?someClass)   , "((", ?mermaidLabelClass,   "))\\n")) as ?mermaidClass)
  BIND(IF(isBlank(?someProperty),CONCAT(?mermaidLabelProperty, "\\n"),CONCAT(str($this),str(?someProperty), "[",  ?mermaidLabelProperty,"]\\n"))  as ?mermaidProperty)
  
  # Establish the inner OWL logic 
  BIND(CONCAT(STR($this),"thing((thing)) --> ", ?mermaidProperty, "\\n", ?mermaidProperty, " -- some --> ", ?mermaidClass) as ?mermaidDefinition)
   
  # Establish label and identifier for the outer OWL logic
  BIND(IF(isBlank($this), ?unboundDummy, function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  
  # Establish the outer OWL logic
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[Restriction &exist; R C]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, "[Restriction 	&exist; R C]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
}  '''.


shp:SerializableOwlRestriction_hasValue
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_hasValue;
    sh:target target:SerializableOwlRestriction_hasValue;
    skos:prefLabel 'Serializable owl restriction owl:hasValue shape'@en.

  target:SerializableOwlRestriction_hasValue
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL class restriction for which the underlying named individual is already serialized to Mermaid diagram language
  
  $this a owl:Restriction;
        owl:hasValue [];
        owl:onProperty ?someProperty.

  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
 }
  '''.

  rule:SerializeOwlRestriction_hasValue
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:hasValue.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:hasValue'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableOwlRestriction_hasValue.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:hasValue ?someIndividual;
        owl:onProperty ?someProperty.
  
  # Establish the label and identifier for the inner OWL logic
  BIND(IF(isBlank(?someIndividual), str(?someIndividual),function:getPrefixedIRI(?someIndividual)) as ?mermaidLabelIndividual)
  BIND(IF(isBlank(?someProperty), str(?someProperty), function:getPrefixedIRI(?someProperty)) as ?mermaidLabelProperty)
  BIND(IF(isBlank(?someIndividual),CONCAT(?mermaidLabelIndividual, "\\n"),CONCAT(str($this),str(?someIndividual), "((", ?mermaidLabelIndividual,"))\\n")) as ?mermaidIndividual)
  BIND(IF(isBlank(?someProperty)  ,CONCAT(?mermaidLabelProperty,   "\\n"),CONCAT(str($this),str(?someProperty),   "[",  ?mermaidLabelProperty  ,"]\\n"))  as ?mermaidProperty)

  # Establish the inner OWL logic   
  BIND(CONCAT(STR($this),"thing((thing)) --> ", ?mermaidProperty, "\\n", ?mermaidProperty, " -- value --> ", ?mermaidIndividual) as ?mermaidDefinition)
    
  # Establish label and identifier for the outer OWL logic
  BIND(IF(isBlank($this), ?unboundDummy, function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  
  # Establish the outer OWL logic
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), " [Restriction &exist; R x]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, "[Restriction &exist; R x]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
} '''.

shp:SerializableOwlRestriction_cardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_cardinality;
    sh:target target:SerializableOwlRestriction_cardinality;
    skos:prefLabel 'Serializable owl restriction owl:cardinality shape'@en.

  target:SerializableOwlRestriction_cardinality
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL class restriction for which the underlying class expressions are already serialized to Mermaid diagram language
  
  $this a owl:Restriction;
        owl:cardinality [];
        owl:onProperty ?someProperty.
   
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:SerializeOwlRestriction_cardinality
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:cardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:cardinality'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableOwlRestriction_cardinality.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:cardinality ?n;
        owl:onProperty ?someProperty.
  
  # Establish the label and identifier for the inner OWL logic
  BIND(IF(isBlank(?someProperty), str(?someProperty), function:getPrefixedIRI(?someProperty)) as ?mermaidLabelProperty)
  BIND(IF(isBlank(?someProperty),CONCAT(?mermaidLabelProperty, "\\n"),CONCAT(str($this),str(?someProperty), "[",  ?mermaidLabelProperty,"]\\n"))  as ?mermaidProperty)
  
  # Establish the inner OWL logic 
  BIND(CONCAT(STR($this),"thing((thing)) --> ", ?mermaidProperty, "\\n", ?mermaidProperty, " -- exactly --> ", str(?n)) as ?mermaidDefinition)
  
  # Establish label and identifier for the outer OWL logic 
  BIND(IF(isBlank($this), ?unboundDummy, function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  
  # Establish the outer OWL logic  
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), " [Restriction = N R]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, "[Restriction = N R]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
}

'''.

shp:SerializableOwlRestriction_maxCardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_maxCardinality;
    sh:target target:SerializableOwlRestriction_maxCardinality;
    skos:prefLabel 'Serializable owl restriction owl:maxCardinality shape'@en.

  target:SerializableOwlRestriction_maxCardinality
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL class restriction for which the underlying class expressions are already serialized to Mermaid diagram language
  
  $this a owl:Restriction;
        owl:maxCardinality [];
        owl:onProperty ?someProperty.
   
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:SerializeOwlRestriction_maxCardinality
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:maxCardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:maxCardinality'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableOwlRestriction_maxCardinality.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:maxCardinality ?n;
        owl:onProperty ?someProperty.
  
  # Establish the label and identifier for the inner OWL logic
  BIND(IF(isBlank(?someProperty), str(?someProperty), function:getPrefixedIRI(?someProperty)) as ?mermaidLabelProperty)
  BIND(IF(isBlank(?someProperty),CONCAT(?mermaidLabelProperty, "\\n"),CONCAT(str($this),str(?someProperty), "[",  ?mermaidLabelProperty,"]\\n"))  as ?mermaidProperty)
  
  # Establish the inner OWL logic 
  BIND(CONCAT(STR($this),"thing((thing)) --> ", ?mermaidProperty, "\\n", ?mermaidProperty, " -- max --> ", str(?n)) as ?mermaidDefinition)
  
  # Establish label and identifier for the outer OWL logic  
  BIND(IF(isBlank($this), ?unboundDummy, function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  
  # Establish the outer OWL logic  
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), " [Restriction ≤ N R]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, "[Restriction ≤ N R]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
}
'''.

shp:SerializableOwlRestriction_minCardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_minCardinality;
    sh:target target:SerializableOwlRestriction_minCardinality;
    skos:prefLabel 'Serializable owl restriction owl:minCardinality shape'@en.

  target:SerializableOwlRestriction_minCardinality
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL class restriction for which the underlying class expressions are already serialized to Mermaid diagram language
  
  $this a owl:Restriction;
        owl:minCardinality [];
        owl:onProperty ?someProperty.
   
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:SerializeOwlRestriction_minCardinality
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:minCardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:minCardinality'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableOwlRestriction_minCardinality.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:minCardinality ?n;
        owl:onProperty ?someProperty.
  
  # Establish the label and identifier for the inner OWL logic
  BIND(IF(isBlank(?someProperty), str(?someProperty), function:getPrefixedIRI(?someProperty)) as ?mermaidLabelProperty)
  BIND(IF(isBlank(?someProperty),CONCAT(?mermaidLabelProperty, "\\n"),CONCAT(str($this),str(?someProperty), "[",  ?mermaidLabelProperty,"]\\n"))  as ?mermaidProperty)
  
  # Establish the inner OWL logic 
  BIND(CONCAT(STR($this),"thing((thing)) --> ", ?mermaidProperty, "\\n", ?mermaidProperty, " -- min --> ", str(?n)) as ?mermaidDefinition)
  
  # Establish label and identifier for the outer OWL logic  
  BIND(IF(isBlank($this), ?unboundDummy, function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  
  # Establish the outer OWL logic  
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), " [Restriction ≥ N R]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, "[Restriction ≥ N R]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
}
'''.

shp:SerializableOwlRestriction_qualifiedCardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_qualifiedCardinality;
    sh:target target:SerializableOwlRestriction_qualifiedCardinality;
    skos:prefLabel 'Serializable owl restriction owl:qualifiedCardinality shape'@en.

  target:SerializableOwlRestriction_qualifiedCardinality
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL class restriction for which the underlying class expressions are already serialized to Mermaid diagram language
  
  $this a owl:Restriction;
        owl:qualifiedCardinality [];
        owl:onProperty ?someProperty.
   
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:SerializeOwlRestriction_qualifiedCardinality
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:qualifiedCardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:qualifiedCardinality'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableOwlRestriction_qualifiedCardinality.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:qualifiedCardinality ?n;
        owl:onProperty ?someProperty;
		owl:onClass ?someClass.
  
  # Establish the label and identifier for the inner OWL logic
  BIND(IF(isBlank(?someProperty), str(?someProperty), function:getPrefixedIRI(?someProperty)) as ?mermaidLabelProperty)
  BIND(IF(isBlank(?someClass), "Anonymous class", function:getPrefixedIRI(?someClass)) as ?qualifyingClassLabel)
  BIND(IF(isBlank(?someProperty),CONCAT(?mermaidLabelProperty, "\\n"),CONCAT(str($this),str(?someProperty), "[",  ?mermaidLabelProperty,"]\\n"))  as ?mermaidProperty)

  # Establish the inner OWL logic 
  BIND(CONCAT(STR($this),"thing((thing)) --> ", ?mermaidProperty, "\\n", ?mermaidProperty,  " -- exactly ", str(?n), " --> ", ?qualifyingClassLabel) as ?mermaidDefinition)
  
  # Establish label and identifier for the outer OWL logic    
  BIND(IF(isBlank($this), ?unboundDummy, function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  
  # Establish the outer OWL logic    
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), " [Restriction = N R]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, "[Restriction = N R]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
}

'''.

shp:SerializableOwlRestriction_maxQualifiedCardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_maxQualifiedCardinality;
    sh:target target:SerializableOwlRestriction_maxQualifiedCardinality;
    skos:prefLabel 'Serializable owl restriction owl:maxQualifiedCardinality shape'@en.

  target:SerializableOwlRestriction_maxQualifiedCardinality
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL class restriction for which the underlying class expressions are already serialized to Mermaid diagram language
  
  $this a owl:Restriction;
        owl:maxQualifiedCardinality [];
        owl:onProperty ?someProperty.
   
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:SerializeOwlRestriction_maxQualifiedCardinality
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:maxQualifiedCardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:maxQualifiedCardinality'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableOwlRestriction_maxQualifiedCardinality.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:maxQualifiedCardinality ?n;
        owl:onProperty ?someProperty;
		owl:onClass ?someClass.
  
  # Establish the label and identifier for the inner OWL logic
  BIND(IF(isBlank(?someProperty), str(?someProperty), function:getPrefixedIRI(?someProperty)) as ?mermaidLabelProperty)
  BIND(IF(isBlank(?someClass), "Anonymous class", function:getPrefixedIRI(?someClass)) as ?qualifyingClassLabel)
  BIND(IF(isBlank(?someProperty),CONCAT(?mermaidLabelProperty, "\\n"),CONCAT(str($this),str(?someProperty), "[",  ?mermaidLabelProperty,"]\\n"))  as ?mermaidProperty)

  # Establish the inner OWL logic 
  BIND(CONCAT(STR($this),"thing((thing)) --> ", ?mermaidProperty, "\\n", ?mermaidProperty,  " -- max ", str(?n), " --> ", ?qualifyingClassLabel) as ?mermaidDefinition)
  
  # Establish label and identifier for the outer OWL logic    
  BIND(IF(isBlank($this), ?unboundDummy, function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)

  # Establish the outer OWL logic   
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), " [Restriction ≤ N R]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, "[Restriction ≤ N R]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
}
'''.

shp:SerializableOwlRestriction_minQualifiedCardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_minQualifiedCardinality;
    sh:target target:SerializableOwlRestriction_minQualifiedCardinality;
    skos:prefLabel 'Serializable owl restriction owl:minQualifiedCardinality shape'@en.

  target:SerializableOwlRestriction_minQualifiedCardinality
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL class restriction for which the underlying class expressions are already serialized to Mermaid diagram language
  
  $this a owl:Restriction;
        owl:minQualifiedCardinality [];
        owl:onProperty ?someProperty.
   
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:SerializeOwlRestriction_minQualifiedCardinality
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:minQualifiedCardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:minQualifiedCardinality'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableOwlRestriction_minQualifiedCardinality.

} where {


  bind(iri(concat(str(doc:), struuid())) as ?node)
  
  $this owl:minQualifiedCardinality ?n;
        owl:onProperty ?someProperty;
		owl:onClass ?someClass.
  
  # Establish the label and identifier for the inner OWL logic
  BIND(IF(isBlank(?someProperty), str(?someProperty), function:getPrefixedIRI(?someProperty)) as ?mermaidLabelProperty)
  BIND(IF(isBlank(?someClass), "Anonymous class", function:getPrefixedIRI(?someClass)) as ?qualifyingClassLabel)
  BIND(IF(isBlank(?someProperty),CONCAT(?mermaidLabelProperty, "\\n"),CONCAT(str($this),str(?someProperty), "[",  ?mermaidLabelProperty,"]\\n"))  as ?mermaidProperty)

  # Establish the inner OWL logic 
  BIND(CONCAT(STR($this),"thing((thing)) --> ", ?mermaidProperty, "\\n", ?mermaidProperty,  " -- min ", str(?n), " --> ", ?qualifyingClassLabel) as ?mermaidDefinition)
  
  # Establish label and identifier for the outer OWL logic    
  BIND(IF(isBlank($this), ?unboundDummy, function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  
  # Establish the outer OWL logic    
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), " [Restriction = N R]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, "[Restriction = N R]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
}
'''.


shp:Serializable_subClassOf
    a sh:NodeShape;
    sh:rule rule:Serialize_subClassOf;
    sh:target target:Serializable_subClassOf;
    skos:prefLabel 'Serializable rdfs:subClassOf shape'@en.

  target:Serializable_subClassOf
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A subclass of some other class
  
  $this rdfs:subClassOf [].
   
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
'''.

  rule:Serialize_subClassOf
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for rdfs:subClassOf classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for rdfs:subClassOf classes.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the class to be serialized.
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_subClassOf.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this rdfs:subClassOf ?superClass.
    
  BIND(IF(isBlank($this), "Anonymous class", function:getPrefixedIRI($this)) as ?classLabel)
  BIND(IF(isBlank(?superClass), "Anonymous class", function:getPrefixedIRI(?superClass)) as ?superClassLabel)
  
  BIND(CONCAT(STR($this), "((",?classLabel,")) -- subClassOf --> ", str(?superClass), "((", ?superClassLabel, "))\\n") as ?mermaidLabel)

} '''.

shp:Serializable_equivalentClass
    a sh:NodeShape;
    sh:rule rule:Serialize_equivalentClass;
    sh:target target:Serializable_equivalentClass;
    skos:prefLabel 'Serializable owl:equivalentClass shape'@en.

  target:Serializable_equivalentClass
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # An equivalent class of some other class, of which the latter's underlying class expressions are already serialized to Mermaid diagram language.
  
  {$this owl:equivalentClass [].
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
  }
  # Also get any equivalent of some atomic class, the latter being undefined. We will infer the mermaid diagram language for this with an heuristic.
  
  UNION 
  
  { $this owl:equivalentClass ?undefinedClass.
  filter not exists {?undefinedClass rdf:type owl:Class}
  filter not exists {?undefinedClass rdf:type owl:Restriction}
  filter not exists {?undefinedClass rdfs:subClassOf []}
  filter not exists {?undefinedClass owl:equivalentClass []}
  filter not exists {?undefinedClass owl:oneOf []}
  filter not exists {?undefinedClass owl:unionOf []}
  filter not exists {?undefinedClass owl:intersectionOf []}
  filter not exists {?undefinedClass owl:complementOf []}
  }
 }
 
  '''.

  rule:Serialize_equivalentClass
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:equivalentClass classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:equivalentClass classes.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the class to be serialized.
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_equivalentClass.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:equivalentClass ?superClass.
    
  BIND(IF(isBlank($this), "Anonymous class", function:getPrefixedIRI($this)) as ?classLabel)
  BIND(IF(isBlank(?superClass), "Anonymous class", function:getPrefixedIRI(?superClass)) as ?superClassLabel)
  
  BIND(CONCAT(STR($this), "((",?classLabel,")) -- equivalentTo --> ", str(?superClass), "((", ?superClassLabel, "))\\n") as ?mermaidLabel)

}
'''.

shp:Serializable_unionOf
    a sh:NodeShape;
    sh:rule rule:Serialize_unionOf;
    sh:target target:Serializable_unionOf;
    skos:prefLabel 'Serializable owl:unionOf shape'@en.

  target:Serializable_unionOf
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL class restriction for which the underlying class expressions are already serialized to Mermaid diagram language
  
  $this owl:unionOf [].
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
   
  # Only classes, not datatypes 
  filter not exists {
   $this rdf:type rdfs:Datatype
   }
}
  '''.

  rule:Serialize_unionOf
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:unionOf classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:unionOf classes.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_unionOf.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  {select (group_concat(str(?mermaidClass);separator=' -- or --- ') as ?mermaidDefinition) where {
           $this owl:unionOf/rdf:rest*/rdf:first ?someClass.
		   
          BIND(IF(isBlank(?someClass),STR(?someClass),CONCAT(STR($this), STR(?someClass),"((",function:getPrefixedIRI(?someClass), "))")) as ?mermaidClass)
    }
  }
   

  BIND(IF(isBlank($this),"Union &cup;",function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[Union C &cup; D]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256," [Union C &cap; D]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
  
}
'''.

shp:Serializable_intersectionOf
    a sh:NodeShape;
    sh:rule rule:Serialize_intersectionOf;
    sh:target target:Serializable_intersectionOf;
    skos:prefLabel 'Serializable owl:intersectionOf shape'@en.

  target:Serializable_intersectionOf
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A class that is the intersection of other classes for which the latter's underlying class expressions are already serialized to Mermaid diagram language
  
  $this owl:intersectionOf [].
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
  
  # Only classes, not datatypes 
  filter not exists {
   $this rdf:type rdfs:Datatype
   }
}
  '''.

  rule:Serialize_intersectionOf
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:intersectionOf classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:intersectionOf classes.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_intersectionOf.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  {select (group_concat(str(?mermaidClass);separator=' -- and --- ') as ?mermaidDefinition) where {
           $this owl:intersectionOf/rdf:rest*/rdf:first ?someClass.
		   
		  BIND(IF(isBlank(?someClass),STR(?someClass),CONCAT(STR($this), STR(?someClass),"((",function:getPrefixedIRI(?someClass), "))")) as ?mermaidClass)
		  
    }		   
  }
  
  BIND(IF(isBlank($this),"Intersection &cap;",function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[Intersection C &cap; D]\\n", ?mermaidDefinition, "\\nend\\n"),
                          CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256," [Intersection C &cap; D]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
  
}
'''.

shp:Serializable_oneOf
    a sh:NodeShape;
    sh:rule rule:Serialize_oneOf;
    sh:target target:Serializable_oneOf;
    skos:prefLabel 'Serializable owl:oneOf shape'@en.

  target:Serializable_oneOf
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL class restriction for which the underlying class expressions are already serialized to Mermaid diagram language
  
  $this owl:oneOf [].
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
   
  # Only classes, not datatypes 
  filter not exists {
   $this rdf:type rdfs:Datatype
   }
 }
  '''.

  rule:Serialize_oneOf
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:oneOf classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:oneOf classes.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_oneOf.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)

  {select (group_concat(str(?mermaidIndividual);separator='\\n') as ?mermaidDefinition) where {
           $this owl:oneOf/rdf:rest*/rdf:first ?someIndividual.
		   
          BIND(function:getPrefixedIRI(?someIndividual) as ?mermaidLabelIndividual)
		  BIND(CONCAT(STR($this), STR(?someIndividual),"((",?mermaidLabelIndividual, "))") as ?mermaidIndividual)
		  
    }	   
  }
  
  BIND(IF(isBlank($this),"Enumeration x &cap; y",function:getPrefixedIRI($this)) as ?classLabel)  
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[Enumeration x &cap; y]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256," [Enumeration x &cap; y]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
}
'''.

shp:Serializable_complementOf
    a sh:NodeShape;
    sh:rule rule:Serialize_complementOf;
    sh:target target:Serializable_complementOf;
    skos:prefLabel 'Serializable owl:complementOf shape'@en.

  target:Serializable_complementOf
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A class that is the complement of some other class, of which the latter's underlying class expressions are already serialized to Mermaid diagram language.
  
  $this owl:complementOf [].
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:Serialize_complementOf
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:complementOf classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:complementOf classes.'@en;
    sh:construct '''
    
construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_complementOf.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:complementOf ?someClass.
		   
  BIND(IF(isBlank(?someClass),STR(?someClass),CONCAT(STR($this), STR(?someClass),"((",function:getPrefixedIRI(?someClass), "))")) as ?mermaidDefinition)
  BIND(IF(isBlank($this),"Negation &not; C",function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[Negation &not; C]\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, " [Negation &not; C]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)
}
'''.

shp:SerializableOwlDisjointClass
    a sh:NodeShape;
    sh:rule rule:SerializeOwlDisjointClass;
    sh:target target:SerializableOwlDisjointClass;
    skos:prefLabel 'Serializable owl:AllDisjointClasses shape'@en.

  target:SerializableOwlDisjointClass
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # Get the class of all disjoint classes
  
  $this a owl:AllDisjointClasses;
        owl:members [].
		
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
 '''.

  rule:SerializeOwlDisjointClass
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:AllDisjointClasses.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:AllDisjointClasses.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableOwlDisjointClass.

} where {
  
  bind(iri(concat(str(doc:), struuid())) as ?node)  
  {select (group_concat(str(?mermaidClass);separator='\\n') as ?mermaidDefinition) where {
           $this owl:members/rdf:rest*/rdf:first ?someClass.
		   
		  BIND(IF(isBlank(?someClass),STR(?someClass),CONCAT(STR($this), STR(?someClass),"((",function:getPrefixedIRI(?someClass), "))")) as ?mermaidClass)
		  
    }		   
  }
  
  BIND(IF(isBlank($this),"DisjointClasses",function:getPrefixedIRI($this)) as ?classLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[DisjointClasses]\\n", ?mermaidDefinition, "\\nend\\n"),
                          CONCAT(STR($this),"((", ?classLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256," [Disjoint]\\n", ?mermaidDefinition, "\\nend\\n")) as ?mermaidLabel)  
}
'''.

shp:Serializable_RDF_Property
    a sh:NodeShape;
   	sh:rule rule:Serialize_RDF_Property;
    sh:target target:Serialize_RDF_Property;
    skos:prefLabel 'Serializable rdf:Property shape'@en.

  target:Serialize_RDF_Property
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # An object property for which underlying class expressions are already serialized to Mermaid diagram language, but which does not have subPropertyOf or equivalentProperty relations.
  
  $this rdf:type rdf:Property.
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

rule:Serialize_RDF_Property
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for the rdfs:domain and rdfs:range of a rdf:Property.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for rdf:Property.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL property to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_RDF_Property.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  BIND(function:getPrefixedIRI($this) as ?propertyLabel)

  # Domain
  OPTIONAL
  {$this rdfs:domain ?domainClass.}
  BIND(COALESCE(STR(?domainClass), "rdfs:Resource") as ?mermaidDomain)
  
  # Range 
  OPTIONAL
  {$this rdfs:range ?rangeClass.}
  BIND(COALESCE(STR(?rangeClass), "rdfs:Resource") as ?mermaidRange)
    
  # Establish the label of the property to be serialized.
  BIND(CONCAT(STR(?mermaidDomain)," -- ",?propertyLabel," --> ", ?mermaidRange) as ?mermaidLabel)
}    
'''.

shp:Serializable_datatypeProperty
    a sh:NodeShape;
	  sh:rule rule:Serialize_datatypeProperty;
    sh:target target:Serialize_datatypeProperty;
    skos:prefLabel 'Serializable owl:DatatypeProperty shape'@en.

  target:Serialize_datatypeProperty
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A datatype property for which underlying class expressions are already serialized to Mermaid diagram language, but which does not have subPropertyOf or equivalentProperty relations.
  
  $this rdf:type owl:DatatypeProperty.
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

rule:Serialize_datatypeProperty
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for the rdfs:domain of an owl:DatatypeProperty.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:DatatypeProperty.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL property to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_datatypeProperty.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)  
  BIND(function:getPrefixedIRI($this) as ?propertyLabel)
  
  # Domain
  OPTIONAL
   {$this rdfs:domain ?domainClass.}
  BIND(COALESCE(STR(?domainClass), "rdfs:Resource") as ?mermaidDomain)
  
  # Range 
  OPTIONAL
   {$this rdfs:range ?rangeDatatype.}
  BIND(COALESCE(STR(?rangeDatatype), "rdfs:Resource") as ?mermaidRange)  
     
  # Establish the label of the property to be serialized.
  BIND(CONCAT(STR(?mermaidDomain)," -- ",?propertyLabel," --> ", ?mermaidRange,":::Datatype") as ?mermaidLabel)
}  
'''.

shp:Serializable_objectProperty
    a sh:NodeShape;
	  sh:rule rule:Serialize_objectProperty;
    sh:target target:Serialize_objectProperty;
    skos:prefLabel 'Serializable owl:ObjectProperty shape'@en.

  target:Serialize_objectProperty
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''
    
select $this {

  # An object property that has not been serialized yet, but which does not have subPropertyOf or equivalentProperty relations.
  
  $this rdf:type owl:ObjectProperty.
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:Serialize_objectProperty
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for the rdfs:domain and rdfs:range of an owl:ObjectProperty.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:ObjectProperty.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL property to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_objectProperty.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  BIND(function:getPrefixedIRI($this) as ?propertyLabel)
  
  # Domain
  OPTIONAL
   {$this rdfs:domain ?domainClass.}
  BIND(COALESCE(STR(?domainClass), "rdfs:Resource") as ?mermaidDomain)

  # Range 
  OPTIONAL
   {$this rdfs:range ?rangeClass.}
  BIND(COALESCE(STR(?rangeClass), "rdfs:Resource") as ?mermaidRange)
  
  # Establish the label of the property to be serialized.
  BIND(CONCAT(STR(?mermaidDomain)," -- ",?propertyLabel," --> ", ?mermaidRange) as ?mermaidLabel)
}    
'''.

shp:Serializable_subPropertyOf
    a sh:NodeShape;
   # sh:rule rule:Serialize_subPropertyOf;
    sh:target target:Serialize_subPropertyOf;
    skos:prefLabel 'Serializable owl:DatatypeProperty shape with a rdfs:subPropertyOf relation.'@en.

  target:Serialize_subPropertyOf
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A datatype or object property for which exists some subproperty relation.
  
  $this rdfs:subPropertyOf ?someProperty.
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
'''.

  rule:Serialize_subPropertyOf
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language for an owl:DatatypeProperty with a subPropertyOf relation.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:DatatypeProperty with a subPropertyOf relation.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL property to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,	shp:Serializable_subPropertyOf.
  
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this rdfs:subPropertyOf ?superProperty.
  
  BIND(CONCAT(STR($this), " -- subPropertyOf --> ", STR(?superProperty)) as ?mermaidLabel)
   
}  
'''.

shp:Serializable_equivalentProperty
    a sh:NodeShape;
    #sh:rule rule:Serialize_equivalentProperty;
    sh:target target:Serialize_equivalentProperty;
    skos:prefLabel 'Serializable owl:DatatypeProperty shape with a owl:equivalentProperty relation.'@en.

  target:Serialize_equivalentProperty
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A datatype or object property for which exists some equivalent property relation.
  $this owl:equivalentProperty ?someProperty.
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
'''.

  rule:Serialize_equivalentProperty
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language for an owl:DatatypeProperty with an equivalentProperty relation.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:DatatypeProperty with an equivalentProperty relation.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL property to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_equivalentProperty.
  
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:equivalentProperty ?superProperty.
  
  BIND(CONCAT(STR($this), " -- equivalentProperty --> ", STR(?superProperty)) as ?mermaidLabel)
   
}  
'''.

shp:Serializable_inverseOf
    a sh:NodeShape;
    sh:rule rule:Serialize_inverseOf;
    sh:target target:Serialize_inverseOf;
    skos:prefLabel 'Serializable owl:DatatypeProperty shape with an owl:inverseOf relation.'@en.

  target:Serialize_inverseOf
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # An anonymous inverseOf relation.

  $this owl:inverseOf ?someProperty.
  filter(isBlank($this))
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
'''.

  rule:Serialize_inverseOf
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language for an owl:ObjectProperty with an inverseOf relation.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:ObjectProperty with an inverseOf relation.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL property to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_inverseOf.
  
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this owl:inverseOf ?someProperty.
  
  
  BIND(IF(isBlank(?someProperty), str(?someProperty), function:getPrefixedIRI(?someProperty)) as ?mermaidLabelProperty)
  BIND(CONCAT("subgraph ", STR($this), "[inverseOf]", "\\n",STR($this), ?mermaidLabelProperty,"[",?mermaidLabelProperty, "]\\nend\\n") as ?mermaidLabel)
   
}  
'''.


shp:Serializable_Datatype
    a sh:NodeShape;
    sh:rule rule:Serialize_Datatype;
    sh:target target:Serializable_Datatype;
    skos:prefLabel 'Serializable rdfs:Datatype shape'@en.

  target:Serializable_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A datatype
  
  $this rdf:type rdfs:Datatype .
   
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
  
  filter not exists {
    $this owl:unionOf []
  }
  filter not exists {
    $this owl:intersectionOf []
  }
  filter not exists {
    $this owl:oneOf []
  }
  filter not exists {
    $this owl:datatypeComplementOf []
  }
  filter not exists {
    $this owl:withRestrictions []
    }
  }
  '''.

  rule:Serialize_Datatype
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for rdfs:Datatype.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for rdfs:Datatype datatypes.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the datatype to be serialized.
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_Datatype.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  $this rdf:type rdfs:Datatype.
    
  BIND(IF(isBlank($this),STR($this),CONCAT(STR($this),"[",function:getPrefixedIRI($this), "]:::Datatype")) as ?mermaidLabel)

} '''.

shp:Serializable_unionOf_Datatype
    a sh:NodeShape;
    sh:rule rule:Serialize_unionOf_Datatype;
    sh:target target:Serializable_unionOf_Datatype;
    skos:prefLabel 'Serializable owl:unionOf Datatype shape'@en.

  target:Serializable_unionOf_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL unionOf datatype for which the underlying datatype expressions are already serialized to Mermaid diagram language
  
  $this owl:unionOf [];
        rdf:type rdfs:Datatype.
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:Serialize_unionOf_Datatype
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:unionOf datatypes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:unionOf datatypes.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL datatype to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_unionOf_Datatype.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  
  {select (group_concat(str(?mermaidDatatype);separator=' -- or --- ') as ?mermaidDefinition) where {
           $this owl:unionOf/rdf:rest*/rdf:first ?someDatatype.
		   
		  BIND(IF(isBlank(?someDatatype),STR(?someDatatype),CONCAT(STR($this), STR(?someDatatype),"((",function:getPrefixedIRI(?someDatatype), "))", ":::Datatype")) as ?mermaidDatatype)
    }
  }
   

  BIND(IF(isBlank($this),"Union &cup;",function:getPrefixedIRI($this)) as ?datatypeLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[Union C &cup; D]\\n","style ", str($this), " fill:#d8f1b3,stroke:#9c6\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"[", ?datatypeLabel, "] -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256," [Union C &cap; D]\\n", ?mermaidDefinition,"\\n style ", str($this), " fill:#d8f1b3,stroke:#9c6\\nend\\n")) as ?mermaidLabel)
  
}
'''.

shp:Serializable_intersectionOf_Datatype
    a sh:NodeShape;
    sh:rule rule:Serialize_intersectionOf_Datatype;
    sh:target target:Serializable_intersectionOf_Datatype;
    skos:prefLabel 'Serializable owl:intersectionOf Datatype shape'@en.

  target:Serializable_intersectionOf_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A datatype that is the intersection of other datatypes for which the latter's underlying datatype expressions are already serialized to Mermaid diagram language
  
  $this owl:intersectionOf [];
        rdf:type rdfs:Datatype.
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:Serialize_intersectionOf_Datatype
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:intersectionOf datatypes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:intersectionOf datatypes.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL datatype to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_intersectionOf_Datatype.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  
  {select (group_concat(str(?mermaidDatatype);separator=' -- and --- ') as ?mermaidDefinition) where {
           $this owl:intersectionOf/rdf:rest*/rdf:first ?someDatatype.
		   
		  BIND(IF(isBlank(?someDatatype),STR(?someDatatype),CONCAT(STR($this), STR(?someDatatype),"((",function:getPrefixedIRI(?someDatatype), "))", ":::Datatype")) as ?mermaidDatatype)
		  
    }		   
  }
  
  BIND(IF(isBlank($this),"Intersection &cap;",function:getPrefixedIRI($this)) as ?datatypeLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[Intersection C &cap; D]\\n","style ", str($this), " fill:#d8f1b3,stroke:#9c6\\n", ?mermaidDefinition, "\\nend\\n"),
                          CONCAT(STR($this),"((", ?datatypeLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256," [Intersection C &cap; D]\\n", ?mermaidDefinition, "\\n style ", str($this), " fill:#d8f1b3,stroke:#9c6\\nend\\n")) as ?mermaidLabel)
  
}
'''.

shp:Serializable_oneOf_Datatype
    a sh:NodeShape;
    sh:rule rule:Serialize_oneOf_Datatype;
    sh:target target:Serializable_oneOf_Datatype;
    skos:prefLabel 'Serializable owl:oneOf Datatype shape'@en.

  target:Serializable_oneOf_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL oneOf datatype for which the underlying datatype expressions are already serialized to Mermaid diagram language
  
  $this owl:oneOf [];
        rdf:type rdfs:Datatype.
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:Serialize_oneOf_Datatype
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:oneOf datatypes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:oneOf datatypes.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL datatype to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_oneOf_Datatype.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)

  {select (group_concat(str(?mermaidLiteral);separator='\\n') as ?mermaidDefinition) where {
           $this owl:oneOf/rdf:rest*/rdf:first ?someLiteral.
		   
          BIND(function:getPrefixedIRI(?someLiteral) as ?mermaidLabelLiteral)
		  BIND(CONCAT(STR($this), STR(?someLiteral),"((",?mermaidLabelLiteral, ")):::Datatype") as ?mermaidLiteral)
		  
    }	   
  }
  
  BIND(IF(isBlank($this),"Enumeration x &cap; y",function:getPrefixedIRI($this)) as ?datatypeLabel)  
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[Enumeration x &cap; y]\\n","style ", str($this), " fill:#d8f1b3,stroke:#9c6\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?datatypeLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256," [Enumeration x &cap; y]\\n", ?mermaidDefinition, "\\n style ", str($this), " fill:#d8f1b3,stroke:#9c6\\nend\\n")) as ?mermaidLabel)
}
'''.

shp:Serializable_complementOf_Datatype
    a sh:NodeShape;
    sh:rule rule:Serialize_complementOf_Datatype;
    sh:target target:Serializable_complementOf_Datatype;
    skos:prefLabel 'Serializable owl:complementOf Datatype shape'@en.

  target:Serializable_complementOf_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A datatype that is the complement of some other datatype, of which the latter's underlying datatype expressions are already serialized to Mermaid diagram language.
  
  $this owl:datatypeComplementOf [].
  
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:Serialize_complementOf_Datatype
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:dataComplementOf datatype.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:dataComplementOf datatype.'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL datatype to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:Serializable_complementOf_Datatype.
        
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  
  $this owl:datatypeComplementOf ?someDatatype.
		   
  BIND(IF(isBlank(?someDatatype),STR(?someDatatype),CONCAT(STR($this), STR(?someDatatype),"((",function:getPrefixedIRI(?someDatatype), ")):::Datatype")) as ?mermaidDefinition)
  BIND(IF(isBlank($this),"Negation &not; C",function:getPrefixedIRI($this)) as ?datatypeLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), "[Negation &not; C]\\n","style ", str($this), " fill:#d8f1b3,stroke:#9c6\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?datatypeLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, " [Negation &not; C]\\n", ?mermaidDefinition, "\\n style ", str($this), " fill:#d8f1b3,stroke:#9c6\\nend\\n")) as ?mermaidLabel)
}
'''.

shp:SerializableOwlRestriction_Datatype
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_Datatype;
    sh:target target:SerializableOwlRestriction_Datatype;
    skos:prefLabel 'Serializable owl restriction datatype owl:withRestrictions shape'@en.

  target:SerializableOwlRestriction_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mermaid:;
    sh:select '''

select $this {

  # A OWL datatype restriction for which the underlying datatype expressions are already serialized to Mermaid diagram language
  
  $this a rdfs:Datatype;
        owl:onDatatype [];
		owl:withRestrictions [].
   
  filter not exists {
  ?node 
        rdf:type html:Text;
        mermaid:fragment [];
        prov:wasDerivedFrom $this.
  }
}
  '''.

  rule:SerializeOwlRestriction_Datatype
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Datatype Restriction owl:withRestrictions.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl datatype restriction owl:withRestrictions'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL datatype to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableOwlRestriction_Datatype.

} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  
  $this owl:onDatatype ?someDatatype.
  
  {select (group_concat(str(?mermaidDatatype);separator='\\n') as ?mermaidDefinition) where {
			
    $this owl:withRestrictions/rdf:rest*/rdf:first ?someRestriction.
			OPTIONAL
			{?someRestriction xsd:minInclusive ?number.
			 BIND(STR(?number) as ?restriction)
             BIND(xsd:minInclusive as ?property)}
			OPTIONAL
			{?someRestriction xsd:maxInclusive ?number.
			 BIND(STR(?number) as ?restriction)
             BIND(xsd:maxInclusive as ?property)}
			OPTIONAL
		    {?someRestriction xsd:minExclusive ?number.
			 BIND(STR(?number) as ?restriction)
             BIND(xsd:minExclusive as ?property)}
			OPTIONAL
			{?someRestriction xsd:maxExclusive ?number.
			 BIND(STR(?number) as ?restriction) 
             BIND(xsd:maxExclusive as ?property)}
			OPTIONAL
			{?someRestriction xsd:pattern ?pattern.
			 BIND(STR(?pattern) as ?restriction) 
             BIND(xsd:pattern as ?property)}             
	
    # Establish the inner OWL logic	   
	BIND(CONCAT(STR($this), STR(?someRestriction),'thing((thing)) --> ', STR($this), STR(?someRestriction),function:getPrefixedIRI(?property), '\\n', STR($this), STR(?someRestriction),function:getPrefixedIRI(?property), '[',function:getPrefixedIRI(?property), '] --> ', STR($this), STR(?someRestriction), '(("',?restriction, '")):::Datatype') as ?mermaidDatatype)
    }		   
  }
  
  # Establish the label & identifier for the outer OWL logic
  BIND(IF(isBlank($this), ?unboundDummy, function:getPrefixedIRI($this)) as ?datatypeLabel)
  BIND(SHA256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  
  # Establish the outer OWL logic
  BIND(IF(isBlank($this),CONCAT("subgraph ",STR($this), " [Datatype Restriction]\\n","style ", str($this), " fill:#d8f1b3,stroke:#9c6\\n", ?mermaidDefinition, "\\nend\\n"),
                         CONCAT(STR($this),"((", ?datatypeLabel, ")) -- equivalentTo --> ",STR($this),?mermaidDefinition_SHA256,"\\n","subgraph ",STR($this),?mermaidDefinition_SHA256, "[Restriction ≥ N R]\\n", ?mermaidDefinition, "\\n style ", str($this), " fill:#d8f1b3,stroke:#9c6\\nend\\n")) as ?mermaidLabel)
}
'''.

shp:SerializableScheme
    a sh:NodeShape;
    sh:rule rule:SerializeScheme;
    sh:targetClass skos:ConceptScheme;
    skos:prefLabel 'Serializable SKOS Scheme shape'@en.

  rule:SerializeScheme
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for a SKOS scheme.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for SKOS scheme'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this,shp:SerializableScheme.
         
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  BIND(CONCAT(STR($this),"[",function:getPrefixedIRI($this), "]:::Scheme") as ?mermaidLabel)
}
'''.


 shp:SerializableConcept
    a sh:NodeShape;
    sh:rule rule:SerializeConcept;
    sh:targetClass skos:Concept;
    skos:prefLabel 'Serializable SKOS Concept shape'@en.

  rule:SerializeConcept
    a sh:SPARQLRule;
    sh:prefixes mermaid:;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for a SKOS concept.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for SKOS concept'@en;
    sh:construct '''

construct {

  # create the Mermaid diagram language for the OWL class to be serialized.
  
  ?node 
         rdf:type html:Text;
         mermaid:fragment ?mermaidLabel;
         prov:wasDerivedFrom $this, shp:SerializableConcept.
         
} where {

  bind(iri(concat(str(doc:), struuid())) as ?node)
  
  {BIND(CONCAT(STR($this),"[",function:getPrefixedIRI($this), "]:::Concept") as ?mermaidLabel)}
    
  UNION
  {$this ?someProperty ?someConcept.
  ?someConcept rdf:type skos:Concept.  
  BIND(function:getPrefixedIRI(?someProperty) as ?propertyLabel)  
  BIND(CONCAT(STR($this), " -- ", ?propertyLabel," --> ", STR(?someConcept)) as ?mermaidLabel)}
  
  UNION
  {$this ?someProperty ?someConceptScheme.
  ?someConceptScheme rdf:type skos:ConceptScheme.     
  BIND(function:getPrefixedIRI(?someProperty) as ?propertyLabel)
  BIND(CONCAT(STR($this), " -- ", ?propertyLabel," --> ", STR(?someConceptScheme)) as ?mermaidLabel)}
}
'''.

function:getPrefixedIRI
    a sh:SPARQLFunction ;
    sh:prefixes mermaid:;
    rdfs:comment "Gets prefixed IRI from full IRI." ;
    skos:example '''Assume an ontology with namespace "http://example.org/", prefix "ex" and a class "Person" as defined by this ontology. The function call will result in "ex:Person" for the IRI http://example.org/Person''';
    sh:parameter [
        sh:path function:IRI ;
        sh:datatype xsd:anyURI ;
        sh:description "The full IRI of a RDF resource as defined in an ontology." ;
    ] ;
    sh:returnType xsd:string ;
    sh:select """

SELECT ?result WHERE {

  # Establish the default full IRI of the resource, e.g. ex:Person would lead to http://example.org/Person.
  bind(str($IRI) as ?fullIRI)

  # Establish possible namespaces through SHACL declarations
  optional
  {
    ?ontology sh:declare ?namespaceDeclaration.
    ?namespaceDeclaration sh:namespace ?namespace;
              # e.g. "http://example.org/"
              sh:prefix ?prefix.       # e.g. "ex"
    filter(strstarts(?fullIRI, str(?namespace))) # e.g. "http://example.org/"
  }
  
  # Establish possible namespaces through VANN declarations
  optional
  {
    ?ontology vann:preferredNamespaceUri ?namespace;
              # e.g. "http://example.org/"
              vann:preferredNamespacePrefix ?prefix.  # e.g. "ex"
    filter(strstarts(?fullIRI, str(?namespace))) # e.g. "http://example.org/"
  }

  # Establish possible namespaces through the Mermaid ontology (generic ontologies like OWL, RDF, et cetera)
  optional 
    {
    mermaid: sh:declare ?namespaceDeclaration.
    ?namespaceDeclaration sh:namespace ?namespace;
              # e.g. "http://example.org/"
              sh:prefix ?prefix.       # e.g. "ex"
    filter(strstarts(?fullIRI, str(?namespace))) # e.g. "http://example.org/"
  }

  # Establish the local name
  bind(strafter(?fullIRI, str(?namespace)) as ?localName)

  # Establish the prefixed IRI if prefix and localName exist, e.g. "ex:Person" or None
  bind(concat(str(?prefix),":",?localName) as ?prefixedIRI)

  # Establish result, either a prefixed IRI or the full IRI, e.g. "ex:Person" or "http://example.org/Person"
  bind(coalesce(?prefixedIRI, ?fullIRI) as ?result)
}
""" .

function:getNodeIRI
    a sh:SPARQLFunction ;
    sh:prefixes mermaid:;
    rdfs:comment "Returns a document node IRI." ;
    sh:returnType xsd:anyURI;
    sh:select """

select ?result where {

  bind(iri(concat(str(doc:), struuid())) as ?result)
}
""" .

}