prefix dcm: <http://purl.org/dc/dcmitype/>
prefix dct: <http://purl.org/dc/terms/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfa: <http://www.w3.org/ns/rdfa#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix sh: <http://www.w3.org/ns/shacl#>
prefix skos: <http://www.w3.org/2004/02/skos/core#>
prefix status: <http://purl.org/adms/status/>
prefix vann: <http://purl.org/vocab/vann/>
prefix void: <http://rdfs.org/ns/void#>
prefix xsd: <http://www.w3.org/2001/XMLSchema#>

prefix decl: <https://data.rijksfinancien.nl/mermaid/id/decl/>
prefix graph: <https://data.rijksfinancien.nl/mermaid/graph/>
prefix mmd: <https://data.rijksfinancien.nl/mermaid/model/def/>
prefix mmdf: <https://data.rijksfinancien.nl/mermaid/model/func/>
prefix param: <https://data.rijksfinancien.nl/mermaid/id/param/>
prefix rule: <https://data.rijksfinancien.nl/mermaid/model/rule/>
prefix section: <https://data.rijksfinancien.nl/mermaid/id/section/>
prefix shp: <https://data.rijksfinancien.nl/mermaid/model/shp/>
prefix standard: <https://data.rijksfinancien.nl/mermaid/id/standard/>
prefix target: <https://data.rijksfinancien.nl/mermaid/model/target/>

  mmd:
    a
      owl:Ontology,
      void:Dataset;
    dct:conformsTo 'https://mermaid.js.org/'^^xsd:anyURI;
    dct:created '2023-07-19'^^xsd:date;
    dct:creator
      'Flores Bakker',
      'Wouter Beek';
    dct:description '''The OntoMermaid Vocabulary models OWL constructs into Mermaid. Mermaid itself is a JavaScript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams. The main purpose of Mermaid is to help documentation catch up with development. This ontology defines the elements and relationships used within Mermaid diagrams, allowing for a standardized way to describe and interact with Mermaid diagrams in the context of the Semantic Web.'''@en;
    dct:abstract '''The OntoMermaid Vocabulary models OWL constructs into Mermaid. Mermaid itself is a JavaScript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams. The main purpose of Mermaid is to help documentation catch up with development. This ontology defines the elements and relationships used within Mermaid diagrams, allowing for a standardized way to describe and interact with Mermaid diagrams in the context of the Semantic Web.'''@en;
    dct:language 'iso639-1:en';
    dct:license 'http://creativecommons.org/licenses/by/4.0'^^xsd:anyURI;
    dct:publisher <https://www.w3.org/community/OntoMermaid/>;
    dct:source <https://github.com/floresbakker/OntoMermaid/>;
    dct:subject 'Mermaid'@en;
    dct:title 'OntoMermaid Vocabulary'@en;
    foaf:homepage 'https://www.w3.org/community/mermaid/'^^xsd:anyURI;
    owl:imports
      dct:,
      owl:,
      prov:,
      rdf:,
      rdfs:,
      sh:,
      skos:;
    owl:versionInfo '0.1.0';
    owl:versionIRI <https://github.com/floresbakker/OntoMermaid/tree/main>;
    sh:declare
      decl:mmd,
      decl:mmdf,
      decl:owl,
      decl:prov,
      decl:rdf,
      decl:rdfs,
      decl:skos,
      decl:vann,
      decl:xsd;
    vann:preferredNamespacePrefix 'mmd';
    vann:preferredNamespaceUri 'https://data.rijksfinancien.nl/mermaid/model/def/';
    void:subSet graph:model;
    void:uriRegexPattern '^https://data.rijksfinancien.nl/mermaid/def/';
    void:uriSpace 'https://data.rijksfinancien.nl/mermaid/model/def/'^^xsd:anyURI.

  decl:mmd
    a sh:PrefixDeclaration;
    sh:prefix "mmd";
    sh:namespace "https://data.rijksfinancien.nl/mermaid/model/def/"^^xsd:anyURI.

  decl:mmdf
    a sh:PrefixDeclaration;
    sh:prefix "mmdf";
    sh:namespace "https://data.rijksfinancien.nl/mermaid/model/func/"^^xsd:anyURI.

  decl:owl
    a sh:PrefixDeclaration;
    sh:prefix 'owl';
    sh:namespace "http://www.w3.org/2002/07/owl#"^^xsd:anyURI.

  decl:prov
    a sh:PrefixDeclaration;
    sh:prefix "prov";
    sh:namespace "http://www.w3.org/ns/prov#"^^xsd:anyURI.

  decl:rdf
    a sh:PrefixDeclaration;
    sh:prefix "rdf";
    sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#"^^xsd:anyURI.

  decl:rdfs
    a sh:PrefixDeclaration;
    sh:prefix "rdfs";
    sh:namespace "http://www.w3.org/2000/01/rdf-schema#"^^xsd:anyURI.

  decl:skos
    a sh:PrefixDeclaration;
    sh:prefix "skos";
    sh:namespace "http://www.w3.org/2004/02/skos/core#"^^xsd:anyURI.

  decl:vann
    a sh:PrefixDeclaration;
    sh:prefix "vann";
    sh:namespace "http://purl.org/vocab/vann/"^^xsd:anyURI.

  decl:xsd
    a sh:PrefixDeclaration;
    sh:prefix "xsd";
    sh:namespace "http://www.w3.org/2001/XMLSchema#"^^xsd:anyURI.

  standard:mmd
    a dct:Standard;
    dct:created '2023-07-19'^^xsd:date;
    dct:source 'https://mermaid.js.org/'^^xsd:anyURI;
    skos:prefLabel 'Mermaid diagram language'@en.

  # OWL Class

  shp:SerializableOwlClass
    a sh:NodeShape;
    sh:rule rule:SerializeOwlClass;
    sh:target target:SerializableOwlClass;
    skos:prefLabel 'Serializable owl class shape'@en.

  target:SerializableOwlClass
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # Any OWL or RDFS class that is not further expressed in class expressions.
  { $this a owl:Class. } union { $this a rdfs:Class. }
  filter not exists { $this rdfs:subClassOf []. }
  filter not exists { $this owl:equivalentClass []. }
  filter not exists { $this owl:unionOf []. }
  filter not exists { $this owl:intersectionOf []. }
  filter not exists { $this owl:complementOf []. }
  filter not exists { $this owl:oneOf []. }
  # The OWL class must not have a Mermaid diagram string yet.
  filter not exists { $this mmd:label []. }
}'''.

  rule:SerializeOwlClass
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for an OWL Class.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl class'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram string for the OWL class to be serialized.
  $this
    mmd:syntax 'CLASS';
    mmd:label ?mermaidLabel.
} where {
  bind(if(isBlank($this),
          str($this),
          concat(str($this),'((',mmdf:getLabel($this),'))')) as ?mermaidLabel)
}'''.

  # OWL Restriction

  shp:SerializableOwlRestriction_AllValuesFrom
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_AllValuesFrom;
    sh:target target:SerializableOwlRestriction_AllValuesFrom;
    skos:prefLabel 'Serializable owl restriction owl:allValuesFrom shape'@en.

  target:SerializableOwlRestriction_AllValuesFrom
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying class expressions
  # are already serialized to Mermaid diagram language.
  $this
    a owl:Restriction;
    owl:allValuesFrom [].
  filter not exists { $this mmd:syntax 'ONLY'. }
}'''.

  rule:SerializeOwlRestriction_AllValuesFrom
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:allValuesFrom.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:allValuesFrom'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'ONLY';
    mmd:label ?mermaidLabel.
} where {
  $this
    owl:allValuesFrom ?someClass;
    owl:onProperty ?someProperty.
  # Establish the label of the class to be serialized.
  bind(if(isBlank(?someClass),
          str(?someClass),
          mmdf:getLabel(?someClass)) as ?mermaidLabelClass)
  # Establish the label of the property to be serialized.
  bind(mmdf:getLabel(?someProperty) as ?mermaidLabelProperty)
  # Establish the full definition of the OWL restriction class to be serialized.
  bind(concat(str($this),'thing((thing)) -- ',str(?mermaidLabelProperty),' only --> ',
              if(isBlank(?someClass),
                 concat(?mermaidLabelClass,'\\n'),
                 concat(str($this),str(?someClass),'((',?mermaidLabelClass,'))\\n'))) as ?mermaidDefinition)
  # Establish the label based on certain preferred labels
  bind(if(isBlank($this),
          ?unboundDummy,
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),'[Restriction &forall; R C]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((', ?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,'[Restriction &forall; R C]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:SerializableOwlRestriction_SomeValuesFrom
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_SomeValuesFrom;
    sh:target target:SerializableOwlRestriction_SomeValuesFrom;
    skos:prefLabel 'Serializable owl restriction owl:someValuesFrom shape'@en.

  target:SerializableOwlRestriction_SomeValuesFrom
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying class expressions
  # are already serialized to Mermaid diagram language.
  $this
    a owl:Restriction;
    owl:someValuesFrom [].
  filter not exists { $this mmd:syntax 'SOME'. }
}'''.

  rule:SerializeOwlRestriction_SomeValuesFrom
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:someValuesFrom.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:someValuesFrom'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'SOME';
    mmd:label ?mermaidLabel.
} where {
  $this
    owl:someValuesFrom ?someClass;
    owl:onProperty ?someProperty.
  # Establish the label of the class to be serialized.
  bind(if(isBlank(?someClass),
          str(?someClass),
          mmdf:getLabel(?someClass)) as ?mermaidLabelClass)
  # Establish the label of the property to be serialized.
  bind(mmdf:getLabel(?someProperty) as ?mermaidLabelProperty)
  # Establish the full definition of the OWL restriction class to be serialized.
  bind(concat(str($this),'thing((thing)) -- ',str(?mermaidLabelProperty),' some --> ',
              if(isBlank(?someClass),
                 concat(?mermaidLabelClass,'\\n'),
                 concat(str($this),str(?someClass),'((',?mermaidLabelClass,'))\\n'))) as ?mermaidDefinition)
  # Establish the label based on certain preferred labels
  bind(if(isBlank($this),
          ?unboundDummy,
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),'[Restriction &exist; R C]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,'[Restriction   &exist; R C]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:SerializableOwlRestriction_hasValue
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_hasValue;
    sh:target target:SerializableOwlRestriction_hasValue;
    skos:prefLabel 'Serializable owl restriction owl:hasValue shape'@en.

  target:SerializableOwlRestriction_hasValue
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying named individual is
  # already serialized to Mermaid diagram language.
  $this
    a owl:Restriction;
    owl:hasValue [].
  filter not exists { $this mmd:syntax 'VALUE'. }
}'''.

  rule:SerializeOwlRestriction_hasValue
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:hasValue.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:hasValue'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'VALUE';
    mmd:label ?mermaidLabel.
} where {
  $this
    owl:hasValue ?someIndividual;
    owl:onProperty ?someProperty.
  # Establish the label of the individual to be serialized.
  bind(mmdf:getLabel(?someIndividual) as ?mermaidLabelIndividual)
  # Establish the label of the property to be serialized.
  bind(mmdf:getLabel(?someProperty) as ?mermaidLabelProperty)
  # Establish the full label of the OWL restriction class to be serialized.
  bind(concat(str($this),str(?someProperty),'[',?mermaidLabelProperty,'] -- value --> ',concat(str($this),str(?someIndividual),'((',?mermaidLabelIndividual,'))\\n')) as ?mermaidDefinition)
  # Establish whether the restriction class has a label of its own or not.
  bind(if(isBlank($this),
          ?unboundDummy,
          mmdf:getLabel($this)) as ?classLabel)
  # Establish the Mermaid label
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),' [Restriction &exist; R x]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,'[Restriction &exist; R x]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:SerializableOwlRestriction_cardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_cardinality;
    sh:target target:SerializableOwlRestriction_cardinality;
    skos:prefLabel 'Serializable owl restriction owl:cardinality shape'@en.

  target:SerializableOwlRestriction_cardinality
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying class expressions
  # are already serialized to Mermaid diagram language.
  $this
    a owl:Restriction;
    owl:cardinality [];
    owl:onProperty ?someProperty.
  filter not exists { $this mmd:syntax 'EXACTLY'. }
}'''.

  rule:SerializeOwlRestriction_cardinality
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:cardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:cardinality'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'EXACTLY';
    mmd:label ?mermaidLabel.
} where {
  $this
    owl:cardinality ?n;
    owl:onProperty ?someProperty.
  # Establish the label of the property to be serialized.
  bind(mmdf:getLabel(?someProperty) as ?mermaidLabelProperty)
  # Establish the full label of the OWL restriction class to be serialized.
  bind(concat(str($this),str(?someProperty),'[',?mermaidLabelProperty,'] -- exactly --> ',str(?n)) as ?mermaidDefinition)
  # Establish the label based on certain preferred labels.
  bind(if(isBlank($this),
          ?unboundDummy,
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),' [Restriction = N R]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,'[Restriction = N R]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

shp:SerializableOwlRestriction_maxCardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_maxCardinality;
    sh:target target:SerializableOwlRestriction_maxCardinality;
    skos:prefLabel 'Serializable owl restriction owl:maxCardinality shape'@en.

  target:SerializableOwlRestriction_maxCardinality
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying class expressions are
  # already serialized to Mermaid diagram language.
  $this
    a owl:Restriction;
    owl:maxCardinality [];
    owl:onProperty ?someProperty.
  filter not exists { $this mmd:syntax 'MAX'. }
}'''.

  rule:SerializeOwlRestriction_maxCardinality
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:maxCardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:maxCardinality'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'MAX';
    mmd:label ?mermaidLabel.
} where {
  $this
    owl:maxCardinality ?n;
    owl:onProperty ?someProperty.
  # Establish the label of the property to be serialized.
  bind(mmdf:getLabel(?someProperty) as ?mermaidLabelProperty)
  # Establish the full label of the OWL restriction class to be serialized.
  bind(concat(str($this),str(?someProperty),'[',?mermaidLabelProperty,'] -- max --> ',str(?n)) as ?mermaidDefinition)
  # Establish the label based on certain preferred labels
  bind(if(isBlank($this),
          ?unboundDummy,
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),' [Restriction ≤ N R]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,'[Restriction ≤ N R]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:SerializableOwlRestriction_minCardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_minCardinality;
    sh:target target:SerializableOwlRestriction_minCardinality;
    skos:prefLabel 'Serializable owl restriction owl:minCardinality shape'@en.

  target:SerializableOwlRestriction_minCardinality
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying class expressions are
  # already serialized to Mermaid diagram language.
  $this
    a owl:Restriction;
    owl:minCardinality [].
  filter not exists { $this mmd:syntax 'MIN'. }
}'''.

  rule:SerializeOwlRestriction_minCardinality
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:minCardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:minCardinality'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'MIN';
    mmd:label ?mermaidLabel.
} where {
  $this
    owl:minCardinality ?n;
    owl:onProperty ?someProperty.
  # Establish the label of the property to be serialized.
  bind(mmdf:getLabel(?someProperty) as ?mermaidLabelProperty)
  # Establish the full label of the OWL restriction class to be serialized.
  bind(concat(str($this),str(?someProperty),'[',?mermaidLabelProperty,'] -- min --> ',str(?n)) as ?mermaidDefinition)
  # Establish the label based on certain preferred labels
  bind(if(isBlank($this),
          ?unboundDummy,
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),' [Restriction ≥ N R]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,'[Restriction ≥ N R]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:SerializableOwlRestriction_qualifiedCardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_qualifiedCardinality;
    sh:target target:SerializableOwlRestriction_qualifiedCardinality;
    skos:prefLabel 'Serializable owl restriction owl:qualifiedCardinality shape'@en.

  target:SerializableOwlRestriction_qualifiedCardinality
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying class expressions
  # are already serialized to Mermaid diagram language.
  $this
    a owl:Restriction;
    owl:qualifiedCardinality [];
    owl:onProperty ?someProperty.
  filter not exists { $this mmd:syntax 'EXACTLYQUALIFIED'. }
}'''.

  rule:SerializeOwlRestriction_qualifiedCardinality
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:qualifiedCardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:qualifiedCardinality'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'EXACTLYQUALIFIED';
    mmd:label ?mermaidLabel.
} where {
  $this
    owl:qualifiedCardinality ?n;
    owl:onProperty ?someProperty;
    owl:onClass ?someClass.
  # Establish the label of the property to be serialized.
  bind(mmdf:getLabel(?someProperty) as ?mermaidLabelProperty)
  # Establish the label of the qualifying class to be serialized.
  bind(if(isBlank(?someClass),
          'Anonymous class',
          mmdf:getLabel(?someClass)) as ?qualifyingClassLabel)
  # Establish the full label of the OWL restriction class to be serialized.
  bind(concat(str($this),str(?someProperty),'[',?mermaidLabelProperty,'] -- exactly ',str(?n),' --> ',qualifyingClassLabel) as ?mermaidDefinition)
  # Establish the label based on certain preferred labels
  bind(if(isBlank($this),
          ?unboundDummy,
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),' [Restriction = N R]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((', ?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,'[Restriction = N R]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:SerializableOwlRestriction_maxQualifiedCardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_maxQualifiedCardinality;
    sh:target target:SerializableOwlRestriction_maxQualifiedCardinality;
    skos:prefLabel 'Serializable owl restriction owl:maxQualifiedCardinality shape'@en.

  target:SerializableOwlRestriction_maxQualifiedCardinality
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying class expressions
  # are already serialized to Mermaid diagram language
  $this
    a owl:Restriction;
    owl:maxQualifiedCardinality [];
    owl:onProperty ?someProperty.
  filter not exists { $this mmd:syntax 'MAXQUALIFIED'. }
}'''.

  rule:SerializeOwlRestriction_maxQualifiedCardinality
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:maxQualifiedCardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:maxQualifiedCardinality'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'MAXQUALIFIED';
    mmd:label ?mermaidLabel.
} where {
  $this
    owl:maxQualifiedCardinality ?n;
    owl:onProperty ?someProperty;
    owl:onClass ?someClass.
  # Establish the label of the property to be serialized.
  bind(mmdf:getLabel(?someProperty) as ?mermaidLabelProperty)
  # Establish the label of the qualifying class to be serialized.
  bind(if(isBlank(?someClass),
          'Anonymous class',
          mmdf:getLabel(?someClass)) as ?qualifyingClassLabel)
  # Establish the full label of the OWL restriction class to be serialized.
  bind(concat(str($this),str(?someProperty),'[',?mermaidLabelProperty, '] -- max ',str(?n),' --> ',qualifyingClassLabel) as ?mermaidDefinition)
  # Establish the label based on certain preferred labels
  bind(if(isBlank($this),
          ?unboundDummy,
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),' [Restriction ≤ N R]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,'[Restriction ≤ N R]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:SerializableOwlRestriction_minQualifiedCardinality
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_minQualifiedCardinality;
    sh:target target:SerializableOwlRestriction_minQualifiedCardinality;
    skos:prefLabel 'Serializable owl restriction owl:minQualifiedCardinality shape'@en.

  target:SerializableOwlRestriction_minQualifiedCardinality
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying class expressions
  # are already serialized to Mermaid diagram language
  $this
    a owl:Restriction;
    owl:minQualifiedCardinality [].
  filter not exists { $this mmd:syntax 'MINQUALIFIED'. }
}'''.

  rule:SerializeOwlRestriction_minQualifiedCardinality
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Restriction owl:minQualifiedCardinality.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl restriction owl:minQualifiedCardinality'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'MINQUALIFIED';
    mmd:label ?mermaidLabel.
} where {
  $this owl:minQualifiedCardinality ?n;
    owl:onProperty ?someProperty;
    owl:onClass ?someClass.
  # Establish the label of the property to be serialized.
  bind(mmdf:getLabel(?someProperty) as ?mermaidLabelProperty)
  # Establish the label of the qualifying class to be serialized.
  bind(if(isBlank(?someClass),
          'Anonymous class',
          mmdf:getLabel(?someClass)) as ?qualifyingClassLabel)
  # Establish the full label of the OWL restriction class to be serialized.
  bind(concat(str($this),str(?someProperty),'[',?mermaidLabelProperty, '] -- min ',str(?n),' --> ',qualifyingClassLabel) as ?mermaidDefinition)
  # Establish the label based on certain preferred labels.
  bind(if(isBlank($this),
          ?unboundDummy,
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),' [Restriction ≥ N R]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((', ?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,'[Restriction ≥ N R]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:Serializable_subClassOf
    a sh:NodeShape;
    sh:rule rule:Serialize_subClassOf;
    sh:target target:Serializable_subClassOf;
    skos:prefLabel 'Serializable rdfs:subClassOf shape'@en.

  target:Serializable_subClassOf
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A subclass of some other -- atomic or composite -- class, of which the latter's
  # underlying class expressions are already serialized to Mermaid Diagram Language.
  {
    $this rdfs:subClassOf [].
    filter not exists { $this mmd:syntax 'SUBCLASSOF'. }
  } union {
    # Also get any subclass of some atomic class, the latter being undefined.
    # We will infer the Mermaid Diagram Language for this with an heuristic.
    $this rdfs:subClassOf ?undefinedClass.
    filter not exists { ?undefinedClass a owl:Class. }
    filter not exists { ?undefinedClass a owl:Restriction. }
    filter not exists { ?undefinedClass rdfs:subClassOf []. }
    filter not exists { ?undefinedClass owl:equivalentClass []. }
    filter not exists { ?undefinedClass owl:oneOf []. }
    filter not exists { ?undefinedClass owl:unionOf []. }
    filter not exists { ?undefinedClass owl:intersectionOf []. }
    filter not exists { ?undefinedClass owl:complementOf []. }
  }
}'''.

  rule:Serialize_subClassOf
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for rdfs:subClassOf classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for rdfs:subClassOf classes.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the class to be serialized.
  $this
    mmd:syntax 'SUBCLASSOF';
    mmd:label ?mermaidLabel.
} where {
  $this rdfs:subClassOf ?superClass.
  bind(if(isBlank($this),
          'Anonymous class',
          mmdf:getLabel($this)) as ?classLabel)
  bind(concat(str($this),'((',?classLabel,')) -- subClassOf --> ',str(?superClass),'\\n') as ?mermaidLabel)
}'''.

  shp:Serializable_equivalentClass
    a sh:NodeShape;
    sh:rule rule:Serialize_equivalentClass;
    sh:target target:Serializable_equivalentClass;
    skos:prefLabel 'Serializable owl:equivalentClass shape'@en.

  target:Serializable_equivalentClass
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An equivalent class of some other class, of which the latter's underlying
  # class expressions are already serialized to Mermaid Diagram Language.
  {
    $this owl:equivalentClass [].
    filter not exists { $this mmd:syntax 'EQUIVALENTTO'. }
  } union {
    # Also get any equivalent of some atomic class, the latter being undefined.
    # We will infer the Mermaid Diagram Language for this with an heuristic.
    $this owl:equivalentClass ?undefinedClass.
    filter not exists { ?undefinedClass a owl:Class. }
    filter not exists { ?undefinedClass a owl:Restriction. }
    filter not exists { ?undefinedClass rdfs:subClassOf []. }
    filter not exists { ?undefinedClass owl:equivalentClass []. }
    filter not exists { ?undefinedClass owl:oneOf []. }
    filter not exists { ?undefinedClass owl:unionOf []. }
    filter not exists { ?undefinedClass owl:intersectionOf []. }
    filter not exists { ?undefinedClass owl:complementOf []. }
  }
}'''.

  rule:Serialize_equivalentClass
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:equivalentClass classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:equivalentClass classes.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the class to be serialized.
  $this
    mmd:syntax 'EQUIVALENTTO';
    mmd:label ?mermaidLabel.
} where {
  $this owl:equivalentClass ?superClass.
  bind(if(isBlank($this),
          'Anonymous class',
          mmdf:getLabel($this)) as ?classLabel)
  bind(concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str(?superClass),'\\n') as ?mermaidLabel)
}'''.

  shp:Serializable_unionOf
    a sh:NodeShape;
    sh:rule rule:Serialize_unionOf;
    sh:target target:Serializable_unionOf;
    skos:prefLabel 'Serializable owl:unionOf shape'@en.

  target:Serializable_unionOf
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying class expressions
  # are already serialized to Mermaid diagram language.
  $this owl:unionOf [].
  filter not exists { $this mmd:syntax 'OR'. }
  # Only classes, not datatypes.
  filter not exists { $this a rdfs:Datatype. }
}'''.

  rule:Serialize_unionOf
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:unionOf classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:unionOf classes.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'OR';
    mmd:label ?mermaidLabel.
} where {
  {
    select (group_concat(str(?mermaidClass);separator=' -- or --- ') as ?mermaidDefinition) {
      $this owl:unionOf/rdf:rest*/rdf:first ?someClass.
      bind(if(isBlank(?someClass),
              str(?someClass),
              concat(str($this),str(?someClass),'((',mmdf:getLabel(?someClass),'))')) as ?mermaidClass)
    }
  }
  bind(if(isBlank($this),
          'Union &cup;',
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),'[Union C &cup; D]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,' [Union C &cap; D]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:Serializable_intersectionOf
    a sh:NodeShape;
    sh:rule rule:Serialize_intersectionOf;
    sh:target target:Serializable_intersectionOf;
    skos:prefLabel 'Serializable owl:intersectionOf shape'@en.

  target:Serializable_intersectionOf
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A class that is the intersection of other classes for which the latter's
  # underlying class expressions are already serialized to Mermaid diagram language.
  $this owl:intersectionOf [].
  filter not exists { $this mmd:syntax 'AND'. }
  # Only classes, not datatypes.
  filter not exists { $this a rdfs:Datatype. }
}'''.

  rule:Serialize_intersectionOf
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:intersectionOf classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:intersectionOf classes.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'AND';
    mmd:label ?mermaidLabel.
} where {
  {
    select (group_concat(str(?mermaidClass);separator=' -- and --- ') as ?mermaidDefinition) {
      $this owl:intersectionOf/rdf:rest*/rdf:first ?someClass.
      bind(if(isBlank(?someClass),
              str(?someClass),
              concat(str($this),str(?someClass),'((',mmdf:getLabel(?someClass),'))')) as ?mermaidClass)
    }
  }
  bind(if(isBlank($this),'Intersection &cap;',mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),'[Intersection C &cap; D]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,' [Intersection C &cap; D]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:Serializable_oneOf
    a sh:NodeShape;
    sh:rule rule:Serialize_oneOf;
    sh:target target:Serializable_oneOf;
    skos:prefLabel 'Serializable owl:oneOf shape'@en.

  target:Serializable_oneOf
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An OWL class restriction for which the underlying class expressions are
  # already serialized to Mermaid diagram language.
  $this owl:oneOf [].
  filter not exists { $this mmd:syntax '{}'. }
  # Only classes, not datatypes
  filter not exists { $this a rdfs:Datatype. }
}'''.

  rule:Serialize_oneOf
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:oneOf classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:oneOf classes.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax '{}';
    mmd:label ?mermaidLabel.
} where {
  {
    select (group_concat(str(?mermaidIndividual);separator='\\n') as ?mermaidDefinition) {
      $this owl:oneOf/rdf:rest*/rdf:first ?someIndividual.
      bind(mmdf:getLabel(?someIndividual) as ?mermaidLabelIndividual)
      bind(concat(str($this),str(?someIndividual),'((',?mermaidLabelIndividual,'))') as ?mermaidIndividual)
    }
  }
  bind(if(isBlank($this),
          'Enumeration x &cap; y',
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),'[Enumeration x &cap; y]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,' [Enumeration x &cap; y]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:Serializable_complementOf
    a sh:NodeShape;
    sh:rule rule:Serialize_complementOf;
    sh:target target:Serializable_complementOf;
    skos:prefLabel 'Serializable owl:complementOf shape'@en.

  target:Serializable_complementOf
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A class that is the complement of some other class, of which the latter's
  # underlying class expressions are already serialized to Mermaid diagram language.
  $this owl:complementOf [].
  filter not exists { $this mmd:syntax 'NOT'. }
}'''.

  rule:Serialize_complementOf
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:complementOf classes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:complementOf classes.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'NOT';
    mmd:label ?mermaidLabel.
} where {
  $this owl:complementOf ?someClass.
  bind(if(isBlank(?someClass),
          str(?someClass),
          concat(str($this),str(?someClass),'((',mmdf:getLabel(?someClass),'))')) as ?mermaidDefinition)
  bind(if(isBlank($this),
          'Negation &not; C',
          mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),'[Negation &not; C]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,' [Negation &not; C]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:SerializableOwlDisjointClass
    a sh:NodeShape;
    sh:rule rule:SerializeOwlDisjointClass;
    sh:target target:SerializableOwlDisjointClass;
    skos:prefLabel 'Serializable owl:AllDisjointClasses shape'@en.

  target:SerializableOwlDisjointClass
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # Get the class of all disjoint classes.
  $this
    a owl:AllDisjointClasses;
    owl:members [].
  filter not exists { $this mmd:syntax 'DISJOINT'. }
}'''.

  rule:SerializeOwlDisjointClass
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:AllDisjointClasses.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:AllDisjointClasses.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL class to be serialized.
  $this
    mmd:syntax 'DISJOINT';
    mmd:label ?mermaidLabel.
} where {
  {
    select (group_concat(str(?mermaidClass);separator='\\n') as ?mermaidDefinition) {
      $this owl:members/rdf:rest*/rdf:first ?someClass.
      bind(if(isBlank(?someClass),
              str(?someClass),
              concat(str($this),str(?someClass),'((',mmdf:getLabel(?someClass),'))')) as ?mermaidClass)
    }
  }
  bind(if(isBlank($this),'DisjointClasses',mmdf:getLabel($this)) as ?classLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),'[DisjointClasses]\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((', ?classLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,' [Disjoint]\\n',?mermaidDefinition,'\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:Serializable_RDF_Property
    a sh:NodeShape;
    sh:rule rule:Serialize_RDF_Property_overview;
    sh:target target:Serialize_RDF_Property;
    skos:prefLabel 'Serializable rdf:Property shape'@en.

  target:Serialize_RDF_Property
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An object property for which underlying class expressions are already
  # serialized to Mermaid diagram language, but which does not have
  # `rdfs:subPropertyOf` or `owl:equivalentProperty` relations.
  $this a rdf:Property.
  filter not exists { $this mmd:syntax 'RDF_PROPERTY'. }
}'''.

  rule:Serialize_RDF_Property_overview
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for the rdfs:domain and rdfs:range of a rdf:Property.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for rdf:Property.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL property to be serialized.
  $this
    mmd:syntax 'RDF_PROPERTY';
    mmd:label ?mermaidLabel.
} where {
  # Domain
  optional { $this rdfs:domain ?domainClass.}
  bind(coalesce(str(?domainClass), 'rdfs:Resource') as ?mermaidDomain)
  # Range
  optional { $this rdfs:range ?rangeClass. }
  bind(coalesce(str(?rangeClass), 'rdfs:Resource') as ?mermaidRange)
  # Establish the label of the property to be serialized.
  bind(concat(str(?mermaidDomain),' -- ',mmdf:getLabel($this),' --> ',?mermaidRange) as ?mermaidLabel)
}'''.

  shp:Serializable_datatypeProperty
    a sh:NodeShape;
    #sh:rule rule:Serialize_datatypeProperty;#TODO
    sh:rule rule:Serialize_datatypeProperty_overview;
    sh:target target:Serialize_datatypeProperty;
    skos:prefLabel 'Serializable owl:DatatypeProperty shape'@en.

  target:Serialize_datatypeProperty
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A datatype property for which underlying class expressions are already
  # serialized to Mermaid diagram language, but which does not have
  # `rdfs:subPropertyOf` or `owl:equivalentProperty` relations.
  $this a owl:DatatypeProperty.
  filter not exists { $this mmd:syntax 'DATATYPEPROPERTY'. }
}'''.

  rule:Serialize_datatypeProperty
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for the rdfs:domain of an owl:DatatypeProperty.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:DatatypeProperty.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # create the Mermaid diagram language for the OWL property to be serialized.
  $this
    mmd:syntax 'DATATYPEPROPERTY';
    mmd:label ?mermaidLabel, ?mermaidDomain, ?mermaidRange.
} where {
  {
    # Label
    bind(concat(str($this),'>',mmdf:getLabel($this),']') as ?mermaidLabel)
  } union {
    # Domain
    $this rdfs:domain ?domainClass.
    bind(concat(str($this),' -- domain --> ',str(?domainClass)) as ?mermaidDomain)
  } union {
    # Range
    $this rdfs:range ?rangeDatatype.
    bind(concat(str($this),' -- range --> ',str(?rangeDatatype)) as ?mermaidRange)
  }
}'''.

  rule:Serialize_datatypeProperty_overview
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for the rdfs:domain of an owl:DatatypeProperty.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:DatatypeProperty.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL property to be serialized.
  $this
    mmd:syntax 'DATATYPEPROPERTY';
    mmd:label ?mermaidLabel.
} where {
  # Domain
  optional {
    $this rdfs:domain ?domainClass.
    bind(coalesce(str(?domainClass), 'rdfs:Resource') as ?mermaidDomain)
  }
  # Range
  optional {
    $this rdfs:range ?rangeDatatype.
    bind(coalesce(str(?rangeDatatype), 'rdfs:Resource') as ?mermaidRange)
  }
  # Establish the label of the property to be serialized.
  bind(concat(str(?mermaidDomain),' -- ',mmdf:getLabel($this),' --> ',?mermaidRange,':::Datatype') as ?mermaidLabel)
}'''.

  shp:Serializable_objectProperty
    a sh:NodeShape;
    #sh:rule rule:Serialize_objectProperty;#TODO
    sh:rule rule:Serialize_objectProperty_overview;
    sh:target target:Serialize_objectProperty;
    skos:prefLabel 'Serializable owl:ObjectProperty shape'@en.

  target:Serialize_objectProperty
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # An object property for which underlying class expressions are already
  # serialized to Mermaid diagram language, but which does not have
  # `rdfs:subPropertyOf` or `owl:equivalentProperty` relations.
  $this a owl:ObjectProperty.
  filter not exists { $this mmd:syntax 'OBJECTPROPERTY'. }
}'''.

  rule:Serialize_objectProperty
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for the rdfs:domain and rdfs:range of an owl:ObjectProperty.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:ObjectProperty.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # create the Mermaid diagram language for the OWL property to be serialized.
  $this
    mmd:syntax 'OBJECTPROPERTY';
    mmd:label ?mermaidLabel,?mermaidDomain, ?mermaidRange.
} where {
  {
    # Label
    bind(concat(str($this),'>',mmdf:getLabel($this),']') as ?mermaidLabel)
  } union {
    # Domain
    $this rdfs:domain ?domainClass.
    bind(concat(str($this),' -- domain --> ',str(?domainClass)) as ?mermaidDomain)
  } union {
    # Range
    $this rdfs:range ?rangeClass.
    bind(concat(str($this),' -- range --> ',str(?rangeClass)) as ?mermaidRange)
  }
}'''.

  rule:Serialize_objectProperty_overview
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for the rdfs:domain and rdfs:range of an owl:ObjectProperty.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:ObjectProperty.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL property to be serialized.
  $this
    mmd:syntax 'OBJECTPROPERTY';
    mmd:label ?mermaidLabel.
} where {
  # domain
  optional {
    $this rdfs:domain ?domainClass.
    bind(coalesce(str(?domainClass), 'rdfs:Resource') as ?mermaidDomain)
  }
  # range
  optional {
    $this rdfs:range ?rangeClass.
    bind(coalesce(str(?rangeClass), 'rdfs:Resource') as ?mermaidRange)
  }
  # Establish the label of the property to be serialized.
  bind(concat(str(?mermaidDomain),' -- ',mmdf:getLabel($this),' --> ',?mermaidRange) as ?mermaidLabel)
}'''.

shp:Serializable_subPropertyOf
    a sh:NodeShape;
    #sh:rule rule:Serialize_subPropertyOf;#TODO
    sh:target target:Serialize_subPropertyOf;
    skos:prefLabel 'Serializable owl:DatatypeProperty shape with a rdfs:subPropertyOf relation.'@en.

  target:Serialize_subPropertyOf
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A datatype or object property for which exists some subproperty relation.
  $this rdfs:subPropertyOf ?someProperty.
  filter not exists { $this mmd:syntax 'SUBPROPERTY'. }
}'''.

  rule:Serialize_subPropertyOf
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language for an owl:DatatypeProperty with a subPropertyOf relation.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:DatatypeProperty with a subPropertyOf relation.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL property to be serialized.
  $this
    mmd:syntax 'SUBPROPERTY';
    mmd:label ?mermaidLabel.
} where {
  $this rdfs:subPropertyOf ?superProperty.
  bind(concat(str($this),' -- subPropertyOf --> ',str(?superProperty)) as ?mermaidLabel)
}'''.

  shp:Serializable_equivalentProperty
    a sh:NodeShape;
    #sh:rule rule:Serialize_equivalentProperty;#TODO
    sh:target target:Serialize_equivalentProperty;
    skos:prefLabel 'Serializable owl:DatatypeProperty shape with a owl:equivalentProperty relation.'@en.

  target:Serialize_equivalentProperty
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A datatype or object property for which exists some equivalent property relation.
  $this owl:equivalentProperty ?someProperty.
  filter not exists { $this mmd:syntax 'EQUIVALENTPROPERTY'. }
}'''.

  rule:Serialize_equivalentProperty
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language for an owl:DatatypeProperty with an equivalentProperty relation.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:DatatypeProperty with an equivalentProperty relation.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL property to be serialized.
  $this
    mmd:syntax 'SUBPROPERTY';
    mmd:label ?mermaidLabel.
} where {
  $this owl:equivalentProperty ?superProperty.
  bind(concat(str($this),' -- equivalentProperty --> ',str(?superProperty)) as ?mermaidLabel)
}'''.

  shp:Serializable_Datatype
    a sh:NodeShape;
    sh:rule rule:Serialize_Datatype;
    sh:target target:Serializable_Datatype;
    skos:prefLabel 'Serializable rdfs:Datatype shape'@en.

  target:Serializable_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A datatype.
  $this a rdfs:Datatype.
  filter not exists { $this mmd:syntax 'DATATYPE'. }
  filter not exists { $this owl:unionOf []. }
  filter not exists { $this owl:intersectionOf []. }
  filter not exists { $this owl:oneOf []. }
  filter not exists { $this owl:datatypeComplementOf []. }
}'''.

  rule:Serialize_Datatype
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for rdfs:Datatype.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for rdfs:Datatype datatypes.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # create the Mermaid diagram language for the datatype to be serialized.
  $this
    mmd:syntax 'DATATYPE';
    mmd:label ?mermaidLabel.
} where {
  $this a rdfs:Datatype.
  bind(if(isBlank($this),
          str($this),
          concat(str($this),'[',mmdf:getLabel($this),']:::Datatype')) as ?mermaidLabel)
}'''.

  shp:Serializable_unionOf_Datatype
    a sh:NodeShape;
    sh:rule rule:Serialize_unionOf_Datatype;
    sh:target target:Serializable_unionOf_Datatype;
    skos:prefLabel 'Serializable owl:unionOf Datatype shape'@en.

  target:Serializable_unionOf_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A `owl:unionOf` datatype for which the underlying datatype expressions
  # are already serialized to Mermaid diagram language.
  $this
    a rdfs:Datatype;
    owl:unionOf [];
  filter not exists { $this mmd:syntax 'OR-DATATYPE'. }
}'''.

  rule:Serialize_unionOf_Datatype
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:unionOf datatypes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:unionOf datatypes.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL datatype to be serialized.
  $this
    mmd:syntax 'OR-DATATYPE';
    mmd:label ?mermaidLabel.
} where {
  {
    select (group_concat(str(?mermaidDatatype);separator=' -- or --- ') as ?mermaidDefinition) {
      $this owl:unionOf/rdf:rest*/rdf:first ?someDatatype.
      bind(if(isBlank(?someDatatype),
              str(?someDatatype),
              concat(str($this),str(?someDatatype),'((',mmdf:getLabel(?someDatatype),')):::Datatype')) as ?mermaidDatatype)
    }
  }
  bind(if(isBlank($this),'Union &cup;',mmdf:getLabel($this)) as ?datatypeLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),'[Union C &cup; D]\\nstyle ',str($this),' fill:#d8f1b3,stroke:#9c6\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'[', ?datatypeLabel,'] -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,' [Union C &cap; D]\\n',?mermaidDefinition,'\\n style ',str($this),' fill:#d8f1b3,stroke:#9c6\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:Serializable_intersectionOf_Datatype
    a sh:NodeShape;
    sh:rule rule:Serialize_intersectionOf_Datatype;
    sh:target target:Serializable_intersectionOf_Datatype;
    skos:prefLabel 'Serializable owl:intersectionOf Datatype shape'@en.

  target:Serializable_intersectionOf_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A datatype that is the intersection of other datatypes for which the latter's
  # underlying datatype expressions are already serialized to Mermaid diagram language
  $this
    owl:intersectionOf [];
    a rdfs:Datatype.
  filter not exists { $this mmd:syntax 'AND-DATATYPE'. }
}'''.

  rule:Serialize_intersectionOf_Datatype
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:intersectionOf datatypes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:intersectionOf datatypes.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL datatype to be serialized.
  $this
    mmd:syntax 'AND-DATATYPE';
    mmd:label ?mermaidLabel.
} where {
  {
    select (group_concat(str(?mermaidDatatype);separator=' -- and --- ') as ?mermaidDefinition) {
      $this owl:intersectionOf/rdf:rest*/rdf:first ?someDatatype.
      bind(if(isBlank(?someDatatype),
              str(?someDatatype),
              concat(str($this),str(?someDatatype),'((',mmdf:getLabel(?someDatatype),')):::Datatype')) as ?mermaidDatatype)
    }
  }
  bind(if(isBlank($this),'Intersection &cap;',mmdf:getLabel($this)) as ?datatypeLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),'[Intersection C &cap; D]\\nstyle ',str($this),' fill:#d8f1b3,stroke:#9c6\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?datatypeLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,' [Intersection C &cap; D]\\n',?mermaidDefinition,'\\n style ',str($this),' fill:#d8f1b3,stroke:#9c6\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:Serializable_oneOf_Datatype
    a sh:NodeShape;
    sh:rule rule:Serialize_oneOf_Datatype;
    sh:target target:Serializable_oneOf_Datatype;
    skos:prefLabel 'Serializable owl:oneOf Datatype shape'@en.

  target:Serializable_oneOf_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A `owl:oneOf` datatype for which the underlying datatype expressions are
  # already serialized to Mermaid diagram language.
  $this
    owl:oneOf [];
    a rdfs:Datatype.
  filter not exists { $this mmd:syntax '{}-DATATYPE'. }
 }'''.

  rule:Serialize_oneOf_Datatype
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:oneOf datatypes.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:oneOf datatypes.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL datatype to be serialized.
  $this
    mmd:syntax '{}-DATATYPE';
    mmd:label ?mermaidLabel.
} where {
  {
    select (group_concat(str(?mermaidLiteral);separator='\\n') as ?mermaidDefinition) {
      $this owl:oneOf/rdf:rest*/rdf:first ?someLiteral.
      bind(mmdf:getLabel(?someLiteral) as ?mermaidLabelLiteral)
      bind(concat(str($this),str(?someLiteral),'((',?mermaidLabelLiteral,')):::Datatype') as ?mermaidLiteral)
    }
  }
  bind(if(isBlank($this), 'Enumeration x &cap; y', mmdf:getLabel($this)) as ?datatypeLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this), '[Enumeration x &cap; y]\\nstyle ', str($this), ' fill:#d8f1b3,stroke:#9c6\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?datatypeLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,' [Enumeration x &cap; y]\\n',?mermaidDefinition,'\\n style ',str($this),' fill:#d8f1b3,stroke:#9c6\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:Serializable_complementOf_Datatype
    a sh:NodeShape;
    sh:rule rule:Serialize_complementOf_Datatype;
    sh:target target:Serializable_complementOf_Datatype;
    skos:prefLabel 'Serializable owl:complementOf Datatype shape'@en.

  target:Serializable_complementOf_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A datatype that is the complement of some other datatype,
  # of which the latter's underlying datatype expressions are already serialized to Mermaid diagram language.
  $this owl:datatypeComplementOf [].
  filter not exists { $this mmd:syntax 'NOT-DATATYPE'. }
}'''.

  rule:Serialize_complementOf_Datatype
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for owl:dataComplementOf datatype.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl:dataComplementOf datatype.'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL datatype to be serialized.
  $this
    mmd:syntax 'NOT-DATATYPE';
    mmd:label ?mermaidLabel.
} where {
  $this owl:datatypeComplementOf ?someDatatype.
  bind(if(isBlank(?someDatatype),
          str(?someDatatype),
          concat(str($this),str(?someDatatype),'((',mmdf:getLabel(?someDatatype),')):::Datatype')) as ?mermaidDefinition)
  bind(if(isBlank($this),'Negation &not; C',mmdf:getLabel($this)) as ?datatypeLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),'[Negation &not; C]\\nstyle ',str($this),' fill:#d8f1b3,stroke:#9c6\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?datatypeLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,' [Negation &not; C]\\n',?mermaidDefinition,'\\n style ',str($this),' fill:#d8f1b3,stroke:#9c6\\nend\\n')) as ?mermaidLabel)
}'''.

  shp:SerializableOwlRestriction_Datatype
    a sh:NodeShape;
    sh:rule rule:SerializeOwlRestriction_Datatype;
    sh:target target:SerializableOwlRestriction_Datatype;
    skos:prefLabel 'Serializable OWL restriction datatype owl:withRestrictions shape'@en.

  target:SerializableOwlRestriction_Datatype
    a sh:SPARQLTarget;
    sh:prefixes mmd:;
    sh:select '''
select $this {
  # A OWL datatype restriction for which the underlying datatype expressions are already serialized to Mermaid diagram language
  $this
    a rdfs:Datatype;
    owl:onDatatype [];
    owl:withRestrictions [].
  filter not exists { $this mmd:syntax 'DATATYPERESTRICTION'. }
}'''.

  rule:SerializeOwlRestriction_Datatype
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a Mermaid diagram language label and definition for OWL Datatype Restriction owl:withRestrictions.'@en;
    skos:prefLabel 'Mermaid diagram language serialisation rule for owl datatype restriction owl:withRestrictions'@en;
    sh:prefixes mmd:;
    sh:construct '''
construct {
  # Create the Mermaid diagram language for the OWL datatype to be serialized.
  $this
    mmd:syntax 'DATATYPERESTRICTION';
    mmd:label ?mermaidLabel.
} where {
  $this owl:onDatatype ?someDatatype.
  {
    select (group_concat(str(?mermaidDatatype);separator='\\n') as ?mermaidDefinition) {
      $this owl:withRestrictions/rdf:rest*/rdf:first ?someRestriction.
      optional {
        ?someRestriction xsd:minInclusive ?number.
        bind(concat('>=',str(?number)) as ?restriction)
      }
      optional {
        ?someRestriction xsd:maxInclusive ?number.
        bind(concat('<=',str(?number)) as ?restriction)
      }
      optional {
        ?someRestriction xsd:minExclusive ?number.
        bind(concat('>',str(?number)) as ?restriction)
      }
      optional {
        ?someRestriction xsd:maxExclusive ?number.
        bind(concat('<',str(?number)) as ?restriction)
      }
      bind(concat(str($this),str(?someRestriction),'((',?restriction,')):::Datatype') as ?mermaidDatatype)
    }
  }
  # Establish the label based on certain preferred labels.
  bind(if(isBlank($this), ?unboundDummy, mmdf:getLabel($this)) as ?datatypeLabel)
  bind(sha256(?mermaidDefinition) as ?mermaidDefinition_SHA256)
  bind(if(isBlank($this),
          concat('subgraph ',str($this),' [Restriction ≥ N R]\\nstyle ',str($this),' fill:#d8f1b3,stroke:#9c6\\n',?mermaidDefinition,'\\nend\\n'),
          concat(str($this),'((',?datatypeLabel,')) -- equivalentTo --> ',str($this),?mermaidDefinition_SHA256,'\\nsubgraph ',str($this),?mermaidDefinition_SHA256,'[Restriction ≥ N R]\\n',?mermaidDefinition,'\\n style ',str($this),' fill:#d8f1b3,stroke:#9c6\\nend\\n')) as ?mermaidLabel)
}'''.

  mmdf:getPrefixedIRI
    a sh:SPARQLFunction;
    rdfs:comment 'Gets prefixed IRI from full IRI.'@en;
    sh:parameter param:iri;
    sh:prefixes mmd:;
    sh:returnType xsd:string;
    sh:select '''
select ?result {
  # We cannot use a Values clause here, due to SHACL pre-bending restrictions,
  # see <https://www.w3.org/TR/shacl/#pre-binding>.
  {
    bind(<http://purl.org/dc/dcmitype/> as ?IRI_base)
    bind('dcm' as ?IRI_prefix)
  } union {
    bind(<http://purl.org/dc/terms/> as ?IRI_base)
    bind('dct' as ?IRI_prefix)
  } union {
    bind(<http://xmlns.com/foaf/0.1/> as ?IRI_base)
    bind('foaf' as ?IRI_prefix)
  } union {
    bind(<http://www.w3.org/2002/07/owl#> as ?IRI_base)
    bind('owl' as ?IRI_prefix)
  } union {
    bind(<http://www.w3.org/ns/prov#> as ?IRI_base)
    bind('prov' as ?IRI_prefix)
  } union {
    bind(<http://www.w3.org/1999/02/22-rdf-syntax-ns#> as ?IRI_base)
    bind('rdf' as ?IRI_prefix)
  } union {
    bind(<http://www.w3.org/ns/rdfa#> as ?IRI_base)
    bind('rdfa' as ?IRI_prefix)
  } union {
    bind(<http://www.w3.org/2000/01/rdf-schema#> as ?IRI_base)
    bind('rdfs' as ?IRI_prefix)
  } union {
    bind(<http://www.w3.org/ns/shacl#> as ?IRI_base)
    bind('sh' as ?IRI_prefix)
  } union {
    bind(<http://www.w3.org/2004/02/skos/core#> as ?IRI_base)
    bind('skos' as ?IRI_prefix)
  } union {
    bind(<http://purl.org/adms/status/> as ?IRI_base)
    bind('status' as ?IRI_prefix)
  } union {
    bind(<http://purl.org/vocab/vann/> as ?IRI_base)
    bind('vann' as ?IRI_prefix)
  } union {
    bind(<http://rdfs.org/ns/void#> as ?IRI_base)
    bind('void' as ?IRI_prefix)
  } union {
    bind(<http://www.w3.org/2001/XMLSchema#> as ?IRI_base)
    bind('xsd' as ?IRI_prefix)
  } union {
    ?ontology
      vann:preferredNamespaceUri ?IRI_base;
      vann:preferredNamespacePrefix ?IRI_prefix.
  }
  filter(strstarts(str($IRI), ?IRI_base))
  bind(str($IRI) as ?IRI_href)
  bind(strafter(str($IRI), ?IRI_base) as ?IRI_reference)
  bind(coalesce(concat(str(?IRI_prefix),':',?IRI_reference), ?IRI_href) as ?result)
}'''.

  param:iri
    a sh:Parameter;
    sh:datatype xsd:anyURI;
    sh:description 'The full IRI of a RDF resource as defined in an ontology.'@en;
    sh:path mmdf:IRI.

  mmdf:getLabel
    a sh:SPARQLFunction;
    rdfs:comment 'Gets a label for a RDF resource.';
    sh:parameter param:resource;
    sh:prefixes mmd:;
    sh:returnType xsd:string;
    sh:select '''
select ?result {
  bind(replace(str($resource), '.*[/#]', '') as ?implicitLabel)
  optional {
    $resource skos:prefLabel ?preferredLabel.
    filter(lang(?preferredLabel) = 'en')
  }
  optional {
    $resource rdfs:label ?alternativeLabel.
    filter(lang(?alternativeLabel) = 'en')
  }
  # Establish label and make sure there are no forbidden characters that could render the Mermaid code invalid
  bind(coalesce(?preferredLabel, ?alternativeLabel, ?implicitLabel) as ?rawResult)
  bind(replace(?rawResult, '\\(|\\)|\\[|\\]|\\{|\\}|<|>', '') as ?result)
}'''.

  param:resource
    a sh:Parameter;
    sh:datatype xsd:anyURI;
    sh:description 'The full IRI of a RDF resource as defined in an ontology.';
    sh:path mmdf:resource.
